# 网络分层

![网络分层模型](C:\Users\63190\Desktop\pics\网络分层模型.png)

1. 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
2. 表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。
3. 会话层：建立及管理会话。

> 由于表示层和会话层一般交给程序开发去定义具体的实现，因此也可以归结为应用层内容。

4. 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
5. 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
6. 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。
7. 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。



# 运输层

网络层将数据发送到指定IP的主机中，而真正通信的则是两个主机中的进程。而运输层实际屏蔽了下层的通信过程，使得应用程序看起来就像两个进程直接相连接进行通信。

## UDP

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。

### 首部格式

![UDP数据格式](C:\Users\63190\Desktop\pics\UDP数据格式.jpg)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

## TCP

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。

### 首部格式

![TCP数据格式](C:\Users\63190\Desktop\pics\TCP数据格式.png)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



### 三次握手

TCP 是面向连接的，因此发送数据前，首先要建立连接。

![三次握手](C:\Users\63190\Desktop\pics\三次握手.png)

建立连接流程大致如下：

1. 服务端：启动，并监听某个端口。（服务端监听状态）
2. 客户端：启动，向服务端某个接口发送建立连接请求。（客户端等待建立连接响应，此时属于第一次握手）
3. 服务端：收到客户端建立连接请求，响应给服务端允许建立连接。（服务端等待接受客户端的响应，此时属于第二次握手）
4. 客户端：收到第三步服务端的响应，然后响应服务端已经接受第三步服务端的响应。（客户端进入数据传输状态，开始发送数据，此时属于第三次握手）
5. 服务端：收到第四步客户端的响应，然后正是进入接收数据状态。（此时正式建立客户端与服务端的连接）

> 第三次握手意义：为了防止失效的连接请求到达服务器，让服务器错误打开连接。
>
> 如果不存在第三次握手，就意味着第二次握手后，客户端和服务端都会建立连接。由于网络是不可靠的，因此客户端发起建立连接请求时可能由于网络延迟，导致重新发送请求，此时网络中存在多个建立连接请求。如果没有第三次握手，那么服务端每收到一个建立连接请求都会建立一个连接，而客户端实际只会建立一个连接，导致服务端多创建的连接实际上是失效连接。



### 四次挥手

![四次挥手](C:\Users\63190\Desktop\pics\四次挥手.jpg)

四次挥手大致流程如下：

1. 客户端：请求断开连接。（客户端停止数据传输等待响应状态，第一次挥手）
2. 服务端：收到客户端断开连接请求，通知应用程序停止发送数据，并响应第一步客户端。（服务端会将剩余没发完的数据继续发送，第二次挥手）
3. 客户端：收到第二步服务端的响应。（客户端接收服务端剩余的数据）
4. 服务端：通知客户端所有数据都发送完了，服务端将要断开连接。（第三次挥手）
5. 客户端：收到服务端断开连接的通知后返回响应。（第四次挥手）
6. 服务端：收到第五步客户端的响应后，服务端正式断开连接。
7. 客户端：第五步后，客户端会等待一段时间后，才正式断开连接。

> 第四次挥手后客户端等待原因：
>
> 1. 确保服务端能收到第四次挥手响应。
> 2. 如果第四次挥手后不等待，而是客户端直接关闭连接，那么当网络不可靠导致服务端多次发送第四步时，会导致残留的第四步会影响新的连接。而等待一段时间的操作，就是为了确保网络中不会存在旧连接的报文段。