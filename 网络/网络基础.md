# 网络分层

![网络分层模型](https://raw.githubusercontent.com/Cavielee/notePics/main/网络分层模型.png)

1. 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
2. 表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。
3. 会话层：建立及管理会话。

> 由于表示层和会话层一般交给程序开发去定义具体的实现，因此也可以归结为应用层内容。

4. 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
5. 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
6. 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。
7. 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。



# 运输层

网络层将数据发送到指定IP的主机中，而真正通信的则是两个主机中的进程。而运输层实际屏蔽了下层的通信过程，使得应用程序看起来就像两个进程直接相连接进行通信。

## UDP

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。

### 首部格式

![UDP数据格式](https://raw.githubusercontent.com/Cavielee/notePics/main/UDP数据格式.jpg)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

## TCP

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信（客户端和服务端都可以传输和接收数据），面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。

### 首部格式

![TCP数据格式](https://raw.githubusercontent.com/Cavielee/notePics/main/TCP数据格式.png)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



### 三次握手

TCP 是面向连接的，因此发送数据前，首先要建立连接。

![三次握手](https://raw.githubusercontent.com/Cavielee/notePics/main/三次握手.png)

建立连接流程大致如下：

1. 服务端：启动，并监听某个端口。（服务端监听状态）
2. 客户端：启动，向服务端某个接口发送建立连接请求。（客户端等待建立连接响应，此时属于第一次握手）
3. 服务端：收到客户端建立连接请求，响应给服务端允许建立连接。（服务端等待接受客户端的响应，此时属于第二次握手）
4. 客户端：收到第三步服务端的响应，然后响应服务端已经接受第三步服务端的响应。（客户端进入数据传输状态，开始发送数据，此时属于第三次握手）
5. 服务端：收到第四步客户端的响应，然后正是进入接收数据状态。（此时正式建立客户端与服务端的连接）

> 第三次握手意义：为了防止失效的连接请求到达服务器，让服务器错误打开连接。
>
> 如果不存在第三次握手，就意味着第二次握手后，客户端和服务端都会建立连接。由于网络是不可靠的，因此客户端发起建立连接请求时可能由于网络延迟，导致重新发送请求，此时网络中存在多个建立连接请求。如果没有第三次握手，那么服务端每收到一个建立连接请求都会建立一个连接，而客户端实际只会建立一个连接，导致服务端多创建的连接实际上是失效连接。



### SYN 攻击

SYN 攻击是 DDOS 攻击的一种。指的是在三次握手过程中，攻击者伪造一系列不存在的源 IP 地址对服务器进行连接请求，导致服务端有大量连接请求停留在二次握手后等待客户端响应状态（半连接状态），由于源 IP 不存在，因此服务端并不能收到客户端响应，会不断重发请求直到超时断开连接。这种攻击方式会占用服务端连接请求队列，导致其他正常的连接请求无法被响应。

解决方案：对发送端 IP 进行黑名单拦截。



### 四次挥手

![四次挥手](https://raw.githubusercontent.com/Cavielee/notePics/main/四次挥手.jpg)

四次挥手大致流程如下：

1. 客户端：请求断开连接。（客户端停止数据传输等待响应状态，第一次挥手）
2. 服务端：收到客户端断开连接请求，通知应用程序停止发送数据，并响应第一步客户端。（服务端会将剩余没发完的数据继续发送，第二次挥手）
3. 客户端：收到第二步服务端的响应。（客户端接收服务端剩余的数据）
4. 服务端：通知客户端所有数据都发送完了，服务端将要断开连接。（第三次挥手）
5. 客户端：收到服务端断开连接的通知后返回响应。（第四次挥手）
6. 服务端：收到第五步客户端的响应后，服务端正式断开连接。
7. 客户端：第五步后，客户端会等待一段时间后，才正式断开连接。

> 第四次挥手后客户端等待原因：
>
> 1. 确保服务端能收到第四次挥手响应。
> 2. 如果第四次挥手后不等待，而是客户端直接关闭连接，那么当网络不可靠导致服务端多次发送第四步时，会导致残留的第四步会影响新的连接。而等待一段时间的操作，就是为了确保网络中不会存在旧连接的报文段。



### 滑动窗口

对于TCP 通信来说，每个 TCP Socket 的内核中都有一个发送缓冲区和一个接收缓冲区， TCP 的全双工的工作模式及 TCP 的滑动窗口就是依赖于这两个独立的 Buffer 和该 Buffer的填充状态。

发送数据时，调用 Socket.send() 将用户空间的 Buffer 数据拷贝到内核的发送缓冲区（此时 send() 调用就会返回），然后硬件设备将在之后某个时刻将发送缓冲区数据发送给目标机器。

目标机器通过硬件设备收到数据后，会将数据保存在内核的接收缓冲区，当用户调用 Socket.read() 时，才会将内核的接收缓冲区读取到用户空间的缓冲区。

从上面可以看到，如果内核的接收缓冲区满了，用户进程没有读取内核的接收缓冲区数据，那么发送端如果继续发送数据，那么这些数据将会被丢失。由于 TCP 是可靠协议，因此对于丢失的数据会重新发送，导致网络拥塞。

为了解决上述问题，提出了滑动窗口的概念。接收端和发送端都会有一个窗口。

数据帧：数据包会切割成多个数据帧发送。

发送端窗口：维护一个可发送的数据帧序列（每个数据帧都有自己的编号），即窗口。当发送的数据帧被接收端确认接收后，发送端窗口对应的数据帧就会被对应标记为确认接收，如果数据帧没有收到确认接收，则会重新发送（可靠传输）。当某个序列之前的所有数据帧都被确认接收后，窗口就会往后移动，发送端可以对后面序列的数据帧进行发送。

接收端窗口：维护一个可接收的数据帧序列，即窗口。当收到发送端的数据帧后，就会向发送端发送该数据帧已确认接收响应。当某个序列之前的所有数据帧都被接收后，窗口就会往后移动，接收端可以对后面序列的数据帧进行接收。

窗口大小：窗口大小跟接收端缓冲区关联，如果接收端缓冲区已满，则窗口不可继续接收数据帧，发送端的窗口大小也会对应改变，不会继续发送数据。



# 网络层

IP 地址是网络通信的地址。客户端通信时，必须知道对方机器在网络上的地址（IP 地址）。

一个局域网中，不能同时存在两台机器同时使用同一个 IP 地址（IP 冲突）。因为无法区分一个 IP 地址的数据应当发送给具体那一台机器。



# 数据链路层

网卡会有一个唯一的物理地址——MAC 地址，机器通过网卡进行数据报文传输和接收。



## ARP 协议

网络传输访问时，虽然知道目标的 IP 地址，但不知道对方的机器 MAC 地址，因此在访问前需要通过 ARP 协议广播一个消息到该 IP 局域网，对应的机器接收到该请求后会将自己的 MAC 地址作为响应。



# IP 地址和 MAC 地址区别

MAC 地址虽然是唯一的，但因为在网络通信中，请求方并不知道该 MAC 地址的机器具体在网络的哪里，因此无法将数据传输到目标机器（除非目标机器在同一局域网内）。因此需要 IP 地址先确定目标机器在哪里，然后将数据报文传输到对应网络中的具体机器。



# 应用层

## DNS

网络之间通信必须经过网络层，即需要知道通信端的 IP 地址。而 IP 地址是一长串数字（xxx.xxx.xxx.xxx），不易于用户记住使用。为了方便记住 IP 地址，提出了一个域名（www.xxx.com）映射绑定一个 IP 地址，用户只需访问对应的域名，由 DNS 服务器通过 DNS 协议解析获得对应的 IP 地址（客户不需要知道）。



# CDN

CDN（Content Delivery Net work ）—— 内容分发网，是一种网络缓存技术。

网站一般会有一些静态资源（图片、脚本、静态页面），为了避免客户端频繁向网站请求这些静态资源，一般会将这些静态资源通过 CDN 放到用户相近的地方，从而减少了网络带宽消耗（直接从 CDN 获取，而不是从网站服务端获取），提高用户响应。



# TCP/IP 协议

Internet 采用 TCP/IP 协议。TCP/IP(Transmission Control Protocol/Internet Protocol)是一种网际互联通信协议，它包括两个核心协议 TCP 和 IP。TCP 称为传输控制协议（传输层），IP 称为互联网络协议（网络层）。

## 原理

TCP/IP 模型有四层（应用层、传输层、网际层、网络接口层），每层分别具有不同的协议和功能，TCP/IP 协议族是一组在不同层上的多个协议的组合。各层在实现自身的功能时，使用它的直接下层提供的服务，同时也为它的直接上层提供服务。

**1. TCP/IP 协议族中各协议之间的关系**

每个应用层协议都是为了解决某一类应用问题而定义的，各种应用进程就是通过不同的应用层协议来使用网络所提供的服务。例如，实现文件传输协议的 FTP 应用进程可以为用户提供计算机之间的文件传输服务，实现超文本传输协议的 HTTP 应用进程可以为用户提供浏览 Web 网页的功能等。

**传输层**

TCP 和 UDP 是两个传输层协议。一般应用进程可以选择使用 TCP 或者 UDP 协议。如果应用层协议要求传输层提供可靠的服务，则应该选择 TCP 协议；否则，如果应用层协议要求较高的数据传输速率，但是可以容忍一定的数据丢失，则可以选择 UDP 协议。TCP 协议的数据单元称为 TCP 报文段或简称 TCP 段（TCP segment），UDP 协议的数据单元称为 UDP 数据报（UDP datagram）。

**网际层**

IP 协议是网际层上的一个主要协议。TCP 和 UDP 协议都可以直接使用 IP 协议所提供的服务。IP 协议的数据传送单位称为 IP 数据报或 IP 分组。TCP 报文段或 UDP 数据报都可以封装在 IP 数据报中，以便在互联网上传输。除 IP协议外，网际层还有其他协议，例如 ICMP 协议用于报告差错和其他重要信息；IGMP 是多播组管理协议，是一个与多播有关的协议；ARP(地址解析协议)和 RARP (逆向地址解析协议)用于提供 IP 地址与物理地址的映射功能。IP 数据报可以在不同的物理网络上进行传送。通过以太网传送的数据单元称为以太网帧，或简称为帧（frame）。

**2．封装和拆封**

在发送方（也称为源主机），当应用程序使用 TCP 或 UDP 传送用户数据时，将用户数据进行组成封装，直到被当做一串比特流送入网络。其中每一层对收到的数据都需要增加一些首部信息，有时还需要增加尾部信息，这些操作过程称为封装。

TCP、UDP、ICMP 和 IGMP 等协议都要使用 IP 数据报传送数据，所以必须在 IP 数据报的首部加入某种标识，以说明是哪个协议的数据封装到了 IP 数据报中。IP 数据报首部定义的一个8位的“协议”宇段就是为此目的而设置的。协议宇段的值为1表示 ICMP，为2表示 IGMP，为6表示 TCP，为17表示 UDP。

类似地，许多应用进程使用 TCP 或 UDP 传送数据，则需要在 TCP 段或 UDP 数据报首部定义一个应用程序标识符。TCP 和 UDP 都使用一个16位的端口号来标识不同的应用程序，TCP 和 UDP 把源端口号和目的端口号分别存人 TCP 段首部和 UDP 数据报首部。网络接口分别发送和接收 IP、ARP、RARP 的数据，同理，也必须在以太网（假定物理网络是一个以太网）的首部加入一个字段，用来说明是哪个协议的数据。为此，以太网帧首部定义了一个16位的类型字段。当接收方（也称目的主机）收到一个以太网帧时，数据就开始在协议栈中自下而上传送。各层协议利用报文首部所携带的协议控制信息做相应的处理，然后去掉各层协议数据单元的首部，将封装的数据交给上层协议。每层协议都要检查协议首部中的协议标识，以确定让哪一个协议接收数据，这个过程称为拆封。下图说明了以太网数据帧的拆封过程。

总而言之，发送数据时需要自上而下，层层封装。接收数据时需要自下而上，层层拆封。



## TCP/IP 和 Http 协议关系

TCP/IP 协议作用是将数据可靠的进行传输，但这些数据只是传输到目标机器，目标机器并不知道具体意义是什么。而 Http 协议（应用层协议）则是定义这些数据的具体意义。



## Socket

Socket 实际上是对 TCP/IP 协议的封装，它的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已。socket 本身并不是协议，它是应用层与 TCP/IP 协议族通信的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）。



# 通信数据转发

## 代理

代理服务器接受客户端的请求，并且转发给其它服务器。

使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。

代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。

[![img](https://github.com/crossoverJie/Interview-Notebook/raw/master/pics/a314bb79-5b18-4e63-a976-3448bffa6f1b.png)](https://github.com/crossoverJie/Interview-Notebook/blob/master/pics/a314bb79-5b18-4e63-a976-3448bffa6f1b.png)



[![img](https://github.com/crossoverJie/Interview-Notebook/raw/master/pics/2d09a847-b854-439c-9198-b29c65810944.png)](https://github.com/crossoverJie/Interview-Notebook/blob/master/pics/2d09a847-b854-439c-9198-b29c65810944.png)



## 网关

与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。

## 隧道

使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。