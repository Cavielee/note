# 传统单体架构

![传统架构](https://raw.githubusercontent.com/Cavielee/notePics/main/传统架构.png)

## 应用层面

对于应用初期来说，所有业务逻辑系统都集成在一个包中（jar/war）部署使用。



## 数据层面

一般应用会将数据存储到数据库中。

对于传统单体架构来说，一般一个应用会将其所有数据都存储在一个数据库中。



## 缺点

### 应用层面

1. 随着应用的不断迭代，其业务体系不断的扩展，导致一个应用十分庞大。
2. 开发成本高。开发人员可能只负责某一模块开发，但却需要了解整个应用中所有的系统。
3. 维护成本高。某个业务修改时，需要将整个应用重新发布部署一遍。
4. 单点问题。一旦某一部分出现异常，可能会导致整个应用不可用。
5. 性能瓶颈。所有业务请求都落到同一个系统中，而硬件资源是有限的，高并发导致应用压力过大，进而可能导致整个应用不可用。



### 数据层面

1. 数据库一旦出现异常，可能会导致整个应用不可用。
2. 性能瓶颈。所有业务请求都落到同一个数据库中，而硬件资源是有限的，数据库压力过大，进而可能导致数据库服务崩溃，应用不可用。
3. 数据库如果出现灾难，将会导致数据丢失。



## 单独部署

![传统架构演变1](https://raw.githubusercontent.com/Cavielee/notePics/main/传统架构演变1.png)

由于应用中会使用到许多中间件，如数据库、缓存 Redis等，这些中间件都部署在单独的机器上。

如果中间件和应用都部署在同一台机器上可能会发生一下问题：

1. 性能瓶颈。由于硬件资源是有限的，因此会导致执行效率下降。
2. 故障问题。如果机器发生异常，此时中间件和应用都将会不可用。

因此，在实际开发中一般建议将中间件和应用分别部署在多台机器上。

最好方案当然是一个应用或者一个中间件部署在一台机器上，但由于机器是需要成本的，因此应该尽可能的利用机器的硬件资源。



# 分布式架构

传统单体架构来说，对于客户端的请求都会落在同一个应用处理。

而分布式架构则是将客户端的请求分给不同的节点应用处理。

分布式架构有两种方式：

1. 集群架构：部署多个相同的应用，每个应用节点都可以处理客户端的请求。解决了单点问题。
2. 服务化架构：将一个应用根据不同的规则（业务、功能等）分成多个子应用系统，并分别部署。彼此之间通过网络进行通信。

> 集群架构和服务化架构并不冲突，两者分别解决传统单体架构的不同问题，并且可以互相使用。



## 集群架构

集群实际上可以为将原本单体节点变成多个相同的节点。

![集群](https://raw.githubusercontent.com/Cavielee/notePics/main/集群.png)

### 集群优点

#### 应用层面

1. 集群节点提供保障，解决了单点问题（高可用）。当某个应用节点异常不可用时，可以由集群中其他节点继续提供服务。
2. 提高性能。集群的节点部署到不同的机器上，从而提供更好的硬件资源；请求分散到集群各个节点处理，减少单个节点的压力。


#### 数据层面

1. 数据库集群可以实现主从模式，通过主从模式可以使数据进行备份（防止单点故障，高可用），并且实现读写分离，降低单点压力。
2. 性能提升。通过读写分离，并且节点一般会部署到不同的机器上，因此每个节点都可以更好的利用硬件资源，从而提高处理效率。



### 集群带来的问题

#### 节点类型

集群中存在多个相同的节点，对于客户端的请求由那个节点去处理，存在两种模式：

1. 平等模式。每个节点都可以处理客户端任意的请求。
2. 主从模式。集群节点区分为主从角色，主节点可以处理任何请求，从节点可以处理读请求，事务请求（修改操作）则会转发给主节点处理。



**（一）平等模式**

对于平等模式下，会存在以下问题：

**数据同步**

客户端的多次请求有可能落在不同的节点上，因此数据会落在不同的节点上，导致数据不一致。

解决方案：

1. 节点之间数据互相同步。
2. 节点数据存储在第三方存储中间件。



**（二）主从模式**

对于主从模式下，会存在以下问题：

**主从选举**

集群中节点需要一种机制去选出主从角色，并且当主节点不可用时，可以从从节点中选出新的主节点。

解决方案：

1. 节点间互相通信，从而实现主从选举和主节点不可用时重新选举主节点。
2. 节点与第三方协调中间件通信，由第三方协调中间件进行主从选举和主节点不可用时重新选举主节点。



#### 节点地址

由于客户端需要访问集群中的服务，因此需要知道集群中所有节点的地址。

解决方案：

1. 客户端手动记录集群中所有节点地址，并进行通信。缺点是所有客户端都需要维护节点地址和通信代码，一旦节点地址发生修改或通信代码逻辑修改，则要修改对应所有客户端。
2. 服务注册中心。集群节点会注册地址信息到第三方中间件（即服务注册中心），并保持通信。客户端只需要从服务注册中心获取地址信息即可，服务注册中心维护节点地址信息，一旦信息发生变化，会通知发送最新地址信息给对应客户端。



#### 负载均衡

客户端请求需要一种机制去选择服务提供的具体节点，这种选择机制即为负载均衡。

负载均衡：顾名思义就是让请求尽可能均匀的落到集群的各个节点上。

解决方案：

1. 客户端自身从服务注册中心获得所有节点地址信息，并通过指定的负载均衡算法选择具体节点访问。
2. 客户端请求发到负载均衡器上，由负载均衡器负责获取所有节点地址信息和节点选择，客户端无需知道请求具体落到那个节点上。（如 Nginx）



#### 分布式会话

分布式会话实际上是上面描述的其中一种数据不一致问题。

在使用 Http 进行客户端与服务端交互时，由于 Http 的无状态特性，请求之间是独立的。而实际场景中，需要多次请求都保留特定的状态（如登陆状态）。为了实现状态保留，提出了服务端 Session 保存、客户端 Cookie 保存。

而在集群中，由于客户端的请求通过负载均衡后可能会落在不同节点，意味着存储在节点中的 Session 状态可能在下一次请求中落在另一个节点而导致不可用。

解决方案：

1. Session 数据复制同步给集群中的所有节点。（缺点是复制同步会带来额外的网络开销，而且可能存在一致性问题）
2. 集中存储在第三方中间件。将 Session 数据存储在第三方中间件（如 Redis），而不是存储在节点本地。
3. 不存储在服务端 Session，而是存储在客户端 Cookie 中。缺点是存储在客户端会存在安全性问题，如客户端串改数据，数据泄露等；需要客户端支持 Cookie；客户端每次请求都需要带上大量 Cookie 数据，增加网络传输压力。



## 服务化架构

所有业务逻辑都冗余在同一个应用节点中，会有以下缺陷：

* 一旦某一个业务中的逻辑异常，可能导致整个系统不可用；
* 开发成本高，可维护性低。所有业务的逻辑都冗余到一个应用中，导致程序员开发中需要了解其他自己不相关的业务逻辑代码。并且某个业务逻辑修改时，需要对整个应用重新发布一次。



为了解决上述问题，提出了服务化的思想。

服务化实际可以理解成按照业务逻辑对应用进行划分，分成若干个不同业务的子系统。

服务化好处：

* 开发人员只需要关心了解自己负责的业务子系统即可。
* 当业务逻辑发生异常时，只会影响当前业务系统，不会影响其他业务系统不可用。
* 当对业务逻辑代码进行修改时，只需重新发布一次该业务系统，不需要操作其他业务系统。
* 应用、数据库等可以根据业务进行垂直拆分，并可以部署到多个物理机器上，使得更加充分的利用系统资源。

![服务化](https://raw.githubusercontent.com/Cavielee/notePics/main/服务化.png)

### 服务化带来的问题

#### 服务分层

业务实际上很多都是相关联的，如下订单的业务，可能会涉及商品、用户、订单逻辑，因此需要进行服务分层。

Web 层是提供业务接口给外部客户端访问的。Web 层会调用底层各个业务系统中心服务，这些中心服务之间没有任何联系，关联逻辑由上层 Web 层控制，并且每个业务中心服务都有单独的数据库。

![微服务架构](https://raw.githubusercontent.com/Cavielee/notePics/main/微服务架构.png)