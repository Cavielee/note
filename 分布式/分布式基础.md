# 传统单体架构

![传统架构](C:\Users\63190\Desktop\pics\传统架构.png)

## 应用层面

对于应用初期来说，所有业务逻辑系统都集成在一个包中（jar/war）部署使用。



## 数据层面

一般应用会将数据存储到数据库中。

对于传统单体架构来说，一般一个应用会将其所有数据都存储在一个数据库中。



## 缺点

### 应用层面

1. 随着应用的不断迭代，其业务体系不断的扩展，导致一个应用十分庞大。
2. 开发成本高。开发人员可能只负责某一模块开发，但却需要了解整个应用中所有的系统。
3. 维护成本高。某个业务修改时，需要将整个应用重新发布部署一遍。
4. 单点问题。一旦某一部分出现异常，可能会导致整个应用不可用。
5. 性能瓶颈。所有业务请求都落到同一个系统中，而硬件资源是有限的，高并发导致应用压力过大，进而可能导致整个应用不可用。



### 数据层面

1. 数据库一旦出现异常，可能会导致整个应用不可用。
2. 性能瓶颈。所有业务请求都落到同一个数据库中，而硬件资源是有限的，数据库压力过大，进而可能导致数据库服务崩溃，应用不可用。
3. 数据库如果出现灾难，将会导致数据丢失。



## 单独部署

![传统架构演变1](C:\Users\63190\Desktop\pics\传统架构演变1.png)

由于应用中会使用到许多组件，如数据库、缓存 Redis等，这些组件都需要额外部署在机器上。

如果组件、应用都部署在同一台机器上可能会发生一下问题：

1. 性能瓶颈。由于硬件资源是有限的，因此会导致应用或组件执行效率会下降。
2. 故障问题。如果机器发生异常，此时组件和应用都将会不可用。

因此，在实际开发中一般建议将组件和应用分别部署在多台机器上。

最好方案当然是一个应用或者一个组件部署在一台机器上，但由于机器是需要成本的，因此应该尽可能的利用机器的硬件资源。





# 分布式架构

传统单体架构来说，对于客户端的请求都会落在同一个应用处理。

而分布式架构则是将客户端的请求分给不同的节点应用处理。

分布式架构有两种方式：

1. 集群架构：部署多个相同的应用，每个应用节点都可以处理客户端的请求。解决了单点问题。
2. 服务化架构：将一个应用根据不同的规则（业务、功能等）分成多个子应用系统，并分别部署。彼此之间通过网络进行通信。

> 集群架构和服务化架构并不冲突，两者分别解决传统单体架构的不同问题，并且可以互相使用。



## 集群架构

集群实际上可以为将原本单体节点变成多个相同的节点。

![集群](C:\Users\63190\Desktop\pics\集群.png)

### 集群优点

#### 应用层面

1. 集群节点提供保障，解决了单点问题（高可用）。当某个应用节点异常不可用时，可以由集群中其他节点继续提供服务。
2. 提高性能。一般集群的节点会部署到不同的机器上，因此每个节点都可以更好的利用硬件资源，从而提高处理效率。


#### 数据层面

1. 数据库集群可以实现主从模式，通过主从模式可以使数据进行备份（防止单点故障，高可用），并且实现读写分离，降低单点压力。
2. 性能提升。通过读写分离，并且节点一般会部署到不同的集体上，因此每个节点都可以更好的利用硬件资源，从而提高处理效率。



### 集群带来的问题

**1.客户端如何访问集群中的节点？**

由于集群节点都是相同的节点（不同的端口或者不同的机器），那么客户端需要一种机制去确定具体访问的是哪一个节点。因此需要解决两个问题：

* 节点地址：客户端需要获取集群中所有节点具体的地址。

* 节点选择：客户端需要根据某个机制选出集群中具体的某个节点。

> 节点选择实际上就是负载均衡，通过负载均衡算法，使得客户端的请求尽量均匀的落在集群上的节点

解决方案：

1. 由第三方组件维护集群中所有节点信息，客户端只需要访问该组件即可获得集群中的节点信息。并在根据自身定义的负载均衡算法选择出节点进行请求。（该方案一般为服务注册中心+负载均衡器）
2. 由第三方组件完成节点地址获取和节点选择，客户端只需将请求发送到该组件，由组件将请求路由给集群中的节点。（如Nginx）



**2.会话问题**

在使用 Http 进行客户端与服务端交互时，由于 Http 的无状态特性，请求之间是独立的。而实际场景中，需要多次请求都保留特定的状态（如登陆状态）。为了实现状态保留，提出了服务端 Session 保存、客户端 Cookie 保存。

而在集群中，由于客户端的请求通过负载均衡后可能会落在不同节点，意味着存储在节点中的 Session 状态可能在下一次请求中落在另一个节点而导致不可用。

解决方案：

1. Session 数据复制同步给集群中的所有节点。（缺点是复制同步会带来额外的网络开销，而且可能存在一致性问题）
2. 存储在第三方组件。将 Session 数据存储在第三方组件（如 Redis），而不是存储在节点本地。
3. 不存储在服务端 Session，而是存储在客户端 Cookie 中。缺点是存储在客户端会存在安全性问题，如客户端串改数据，数据泄露等；需要客户端支持 Cookie；客户端每次请求都需要带上大量 Cookie 数据，增加网络传输压力。



## 服务化架构

所有业务逻辑都冗余在同一个应用节点中，会有以下缺陷：

* 一旦某一个业务中的逻辑异常，可能导致整个系统不可用；
* 开发成本高，可维护性低。所有业务的逻辑都冗余到一个应用中，导致程序员开发中需要了解其他自己不相关的业务逻辑代码。并且某个业务逻辑修改时，需要对整个应用重新发布一次。



为了解决上述问题，提出了服务化的思想。

服务化实际可以理解成按照业务逻辑对应用进行划分，分成若干个不同业务的子系统。

服务化好处：

* 开发人员只需要关心了解自己负责的业务子系统即可。
* 当业务逻辑发生异常时，只会影响当前业务系统，不会影响其他业务系统不可用。
* 当对业务逻辑代码进行修改时，只需重新发布一次该业务系统，不需要操作其他业务系统。
* 应用、数据库等可以根据业务进行垂直拆分，并可以部署到多个物理机器上，使得更加充分的利用系统资源。

![服务化](C:\Users\63190\Desktop\pics\服务化.png)

# 分布式架构带来的问题

## 服务地址管理

**应用地址**

应用会根据业务拆分成多个子系统，而每个系统为了避免单点



## 负载均衡

为了降低单点压力，应用节点会使用集群的方式。

对于客户端的访问

负载均衡实际上是一种路由算法。

# RPC

Http 是一种应用层协议

用于客户端和服务端的通信，客户端一般为浏览器。

Http 协议是一种请求响应的协议。

通信流程：

1. 建立连接
2. 客户端请求
3. 服务端响应

Http 1.0时，该协议是短连接。意味着客户端每次发起请求前都会先和服务端建立连接，然后发送请求，服务端处理完后会响应请求，收到响应后连接就会断开。因此缺点很明显：频繁创建、销毁连接。

Http 1.1支持一种伪长链接。为了避免短连接导致频繁创建、销毁连接。Http 1.1提供了一种心跳机制，客户端每隔一段时间会发送一次心跳包（特殊的请求），当客户端一段时间没有收到服务端的心跳响应，或者服务端没收到客户端的心跳请求，则会断开连接。

缺点：实际上不是一种真正意义上的长链接，例如 IM（通信）系统中，服务端不能主动推送数据给客户端，需要客户端不断轮询发起请求去获取数据，服务端收到请求才会响应。

Http 是无状态协议，意味着即使是来自于同一个客户端，但由于是不同的连接，无法进行识别。因此为了解决这个问题，通过服务端Session和客户端Cookie进行状态保留。

Http 协议由两个部分组成：协议头和协议体，因此像上述 Http 1.1实现IM系统时，服务端只关心请求体，客户端只关心响应体，但由于协议必须有协议头，因此导致协议头属于不必要的内容，额外增加网络传输负担。



WebSocket 是基于 Http 协议之上的协议，首先通过 Http 建立连接，然后升级为 WebSocket 协议。

WebSocket 是真正意义上的长链接，是一种双向通信的连接，客户端可以发起请求，服务端也可以主动推送。



RMI——远程方法调用，Java 提供的两个Java进程的方法调用。

客户端本地调用方法（stub），底层实际是通过socket方式将调用的方法信息序列化传输到服务端。

服务端收到skeleton收到信息后反序列化得到调用的方法，并反射调用，然后将结果序列化返回给客户端。





RPC——远程过程调用，实际和RMI相似，但RPC一般是跨语言。



WebService 也可以看做是一种 RPC 框架，但 RPC 一般是基于 Socket 数据传输，而 WebService 则是通过 http 数据传输，



内网服务与服务之间的调用一般推荐使用 RPC 框架。