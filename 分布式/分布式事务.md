# 分布式事务

## 由来

数据库本身提供事务，确保 ACID 的特性。数据库默认事务粒度为每条 SQL 语句建立一个事务，并在 SQL 语句执行完后自动提交或者执行失败进行回滚。

而实际中，一个业务处理往往涉及多次数据库操作，需要以业务为事务粒度，对业务中的所有数据库操作执行成功或失败回滚。

因此数据库提供 XA 接口，允许外部去控制事务的提交和回滚。

## 分布式事务情景

1. 分库

业务处理的数据库操作落在多个数据库中，而数据库提供的事务本身只能确保自己数据库操作的 ACID 特性，无法干涉其他数据库。

![事务场景-分库](C:\Users\63190\Desktop\pics\事务场景-分库.png)

2. 数据分片

使用分库分表中间件后，一个业务的多个数据库操作可能落在多个数据库或一个数据库中的多张表。对于业务逻辑而言，底层的数据分片情况是不透明的，因此也没有办法依赖于数据库提供的单机事务机制。

![事务场景-分片](C:\Users\63190\Desktop\pics\事务场景-分片.png)

3. 微服务架构

在微服务架构中，一个业务的处理可能涉及多个服务应用的调用，而不同的服务应用会使用不同的数据源。在这种情况下，数据库提供的单机事务机制，仅仅能保证其中单一环节的 ACID 特性，没有办法延伸到全局。

![事务情景-微服务](C:\Users\63190\Desktop\pics\事务情景-微服务.png)



## 解决策略

### XA 接口

数据库提供 XA 接口，允许外部去控制事务的提交/回滚。

### 协调者

协调者作用：

1. 分布式架构中：多个应用节点从上面可以知道，第三方协调者主要作用是创建一个事务（通过数据库提供的 XA 接口进行操作），使得多个数据库操作（可能落在多个应用节点上，也可能落在多个数据库上）保持 ACID 特性。



### 2PC

二阶段提交：Two-phase Commit 

可以保证一个事务跨越多个节点时保持 ACID 特性。

两类节点：协调者（Coordinator）和参与者（Participants），协调者只有一个，参与者可以有多个。

JTA中协调者即 TransactionMananger，参与者为数据库。

许多数据库都对外提供 XA 接口，通过 XA 接口对事务进行提交和回滚。

##### 运行过程

1. 执行阶段：协调者询问参与者事务是否执行成功；
2. 提交阶段：如果事务在每个参与者上都执行成功，协调者则发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。

在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

##### 存在的问题

- 阻塞式事务。当某个参与者发生故障或执行时间很长，其他参与者必须等待该参与者返回响应给协调者，协调者才能发送执行提交/失败命令给参与者。
  - 解决方案：可以给事务设置一个超时时间，如果某个参与者一直不响应，那么认为事务执行失败。
- 数据不一致。协调者收到参与者1的失败通知，还没来得急通知其他参与者进行回滚就发生故障，此时重启后没有了参与者1的信息而根据其他参与者成功通知进行了提交事务。
  - 解决方案：将操作日志同步到备用协调者，让备用协调者接替后续工作。



#### 3PC

1. 准备阶段。协调者询问参与者是否可以执行事务。
2. 执行事务。若所有参与者表示可以执行事务，则会发送 ACK 让参与者执行事务。
3. 提交阶段。根据参与者事务执行结果来判断是否提交事务/回滚事务。



3PC 好处：

* 加入了超时机制，若协调者或参与者在规定时间内没有接收到来自其他节点的响应，就会根据当前状态选择提交或回滚事务。
* 当参与者发送了 ACK 之后长时间没收到协调者的响应，则会默认提交事务（因为有了第一步准备阶段，当进入第二阶段时，就证明其他节点表明都可以执行事务。因此即使协调者宕机没响应，也不会影响参与者提交事务。）



#### XA 事务

数据库提供 XA 接口，允许外部去控制事务的提交/回滚。

事务管理器为协调者，而资源管理器就是分布式事务的参与者。

- 资源管理器提供了访问事务资源的能力，数据库就是一种常见的资源管理器，它能够提交或者回滚其管理的事务；
- 事务管理器协调整个分布式事务的各个部分，它与多个资源管理器通信，分别处理他们管理的事务，这些事务都是整体事务的一个分支。

XA 事务实现实际使用的是 2PC 协议。XA 能够保证较强的一致性，但是在 MySQL XA 的执行过程中会对相应的资源加锁，阻塞其他事务对该资源的访问，如果事务长时间没有 COMMIT 或者 ROLLBACK，其实会对数据库造成比较严重的影响。

#### 消息队列

消息中间件也可称作消息系统 (MQ)，它本质上是一个暂存转发消息的一个中间件。在分布式应用当中，我们可以把一个业务操作转换成一个消息，比如支付宝的余额转入余额宝操作，支付宝系统执行减少余额操作之后向消息系统发送一个消息，余额宝系统订阅这条消息然后进行增加余额宝操作。

（一）发送端的可靠性

发送端完成操作后一定能将消息成功发送到消息系统。

实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息中间件，若转移消息成功则删除消息表中的数据，否则继续重传。

（二）接收端的可靠性

接收端能够从消息中间件成功消费一次消息。

实现方法：

- 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。
- 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。



由于使用事务效率低，一般在强一致性的业务要求下才需要用事务。而某些情况下需要快速响应用户，因此一般使用最终一致性，把业务操作作为消息存储在消息队列中，然后响应用户，并在不确定时间处理消息队列的消息。利用了失败重试、补偿机制、预警等手段，确保最终一致性。

