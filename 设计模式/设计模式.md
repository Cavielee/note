# 设计模式

## 七大设计原则

### 1.开闭原则

**开闭原则** 是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。例如商品，他会有一些最基础的方法，如**商品号、商品名、商品价格**等。

```java
public interface IGoods {
    Integer getId();
    String getName();
    Double getPrice();
}
```

实际商品如运动鞋应该实现该接口，并提供具体实现：

```java
public class SportShoes implements IGoods {
    private Integer id;
    private String name;
    private Double price;
    
    public SportShoes(Integer id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    
    @Override
    public Integer getId() {
        ...
    }
    @Override
    public String getName() {
        ...
    }
    @Override
    public Double getPrice() {
        ...
    }
}
```

然而，有时候运动鞋价格会打折，此时我们不应该修改运动鞋实现的逻辑，因为存在其他调用者，导致影响其他调用结果。因此我们应该不修改已有代码**（关闭）**，应该使用一个新的类继继承 **SportShoes** 类**（开放）**。



### 2.单一原则

**单一原则** 指类/方法只负责单一职责，不应存在多个职责使其发生改变。例如商品购买区分会员购买，错误做法：

```java
public class Goods{
    public void buy(Customer customer) {
        if (customer.isVip()) {
       
        } else {
            
        }
    }
}
```

该购买方法会因为普通购买和会员购买两个因素导致改变，我们应当把这两种区别解耦出来。

```java
public class VipBuyGoods {
    public void buy(Customer customer) {
        
    }
}

public class NormalBugGoods {
    public void buy(Customer customer) {
       
    }
}
```

第二个例子：例如我们修改商品信息时我们通常会写成

```java
public void modifyGoodsInfo(Sting name, Double price) {
    this.name = name;
    this.price = price;
}
```

上面可以看到一个修改商品信息的方法，不仅负责修改商品名，还负责修改商品价格，此时存在多个因素导致修改该方法。我们更推崇将上述修改独立出来，这样方便我们后期维护。

```java
public void modifyGoodsName(Sting name) {
    this.name = name;
}
public void modifyGoodsPrice(Double price) {
    this.price = price;
}
```



### 3.依赖倒置

**依赖倒置原则**指各个类或接口不应相互依赖其实现细节，应该依赖抽象。例如客户购买商品：

```java
public class Customer {
    public void buyShoes() {
        
    }
    public void buyClothes() {
        
    }
}

public static void main() {
    Customer c = new Customer();
    c.buyShoes();
    c.buyClothes();
}
```

客户购买商品可能不断的增加，每增加一个就可能多谢一个方法并调用。此时我们不应该依赖其具体细节，应该依赖接口：

```java
public class Customer {
    public void buy(IGoods goods) {
    	
	}
}

public interface IGoods  {
}

public class Shoes implements IGoods {
}

public class Clothes implements IGoods {
}

public static void main() {
    Customer c = new Customer();
    c.buy(new Shoes());
    c.buy(new Clothes());
}
```

此时客户只需提供一个购买的接口，参数为依赖的商品，将具体的细节交给传进来的商品去实现。



### 4.接口隔离原则

**接口隔离原则** 指一个类不应该依赖不需要的接口，接口不应该臃肿，适当的对接口进行细化成多个接口。例如动物会有游泳、飞、行走的区分，因此我们可以对动物这个抽象接口在进行细分

```java
public interface IAnimal {
    void eat();
}

public interface ISwimAnimal {
    void swim();
}

public interface IFlyAnimal {
    void fly();
}
```



### 5. 迪米特法则

**迪米特法则**又叫**最少知道原则**，指的是一个类对其所依赖的类知道的越少越好。例如类的方法，内部成员等应当对其权限修饰符进行控制，例如老板需要店员进行统计今日商品销售情况，今日商品销售需要依赖账单才能统计出来。老板实际只关心统计出来的结果，并不关心账单，因此账单对象应当封装在店员对象中，而老板并不需要依赖账单。



### 6.里氏替换原则

**里氏替换原则**指子类可以扩展父类的功能，但不能改变父类原有的功能。

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2. 子类中可以增加自己特有的方法。
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类
   方法的输入参数更宽松。
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即
   方法的输出/返回值）要比父类更严格或相等



### 7.合成复用原则

**合成复用原则**是指尽量使用对象组合(has-a)/聚合(contains-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱
复用，对类以外的对象是无法获取到实现细节的





## 工厂模式

### 简单工厂模式

**简单工厂模式**适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。客户端不需要每次编写大量重复对象创建代码，只需要提供类/类名等参数即可获得对象，客户端并不需要知道该对象的具体实现，只需要面向接口，调用接口方法即可。

常见工厂模式例子：

* Spring IOC中BeanFactory通过类/类名获取Bean实例对象
* JDK中Calender通过时区等参数获取Calender对象
* 日志中LoggerFactory通过类/类名获取Logger实例对象



**缺点**：

* 工厂类的职责相对过重，不易于扩展过于复杂的产品结构。每个工厂的方法只能返回一种对象（面向接口），若此时需要返回另一种对象（另一个接口），则需要新增一个方法。
* 每多一种实现，就需要修改方法，违背了开闭原则，不利于扩展维护。



### 工厂方法模式

**工厂方法模式**是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。即把工厂创建对象的方法抽象出来，创建那种对象则创建对应的工厂对象，解决了简单工厂模式中每新增一种子对象都修改方法，改变成只需扩展对应的工厂类。

例子：如上面提到的LoggerFactory中，其获得Logger对象首先会获取其对应的工厂对象，再由该工厂对象获取Logger对象。

**适用场景**：

1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
3. 一个类通过其子类来指定创建哪个对象。

**缺点**：

1. 类的个数容易过多，增加复杂度。
2. 增加了系统的抽象性和理解难度。



### 抽象工厂模式

**抽象工厂模式**是指提供一个创建一系列相关的产品对象（属于同一产品族）的接口，无须指定他们具体的类。即一个接口里面提供多个对象的创建方法。

**缺点：**

- 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂
  的接口，违背了开闭原则。
- 增加了系统的抽象性和理解难度。



但在实际应用中，由于开发早期并不知道产品族是否庞大，因此不必拘谨开闭原则问题。若后续有大量的产品，则可以进行优化。



## 单例模式

**单例模式**指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

> 单例模式与原型模式是相违背的



**单例模式注意点：**

* 构造函数要私有化
* 提供一个全局访问方法获取类实例
* 注意线程安全问题
* 注意反射破坏单例
* 注意序列化破坏单例



**常见案例：**

* ServletContext 、ServletContextConfig 等；
* 在Spring 框架应用中ApplicationContext；
* 数据库的连接池也都是单例形式。



### 饿汉式

**饿汉式单例**是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线
程还没出现以前就是实例化了，不可能存在访问安全问题。



```java
public class HungrySingletonObject {
    // 类加载时立刻初始化并创建单利对象
    private static final HungrySingletonObject INSTANCE = new HungrySingletonObject();
    // 构造函数私有化
    private HungrySingletonObject() {}
    public static HungrySingletonObject getInstance() {
        return INSTANCE;
    }
}
```



另一种写法：

```java
public class HungrySingletonObject {
    // 类加载时立刻初始化并创建单利对象
    private static final HungrySingletonObject INSTANCE;
    
    // 利用静态代码块机制
    static {
         INSTANCE = new HungrySingletonObject();
    }
    // 构造函数私有化
    private HungrySingletonObject() {}
    public static HungrySingletonObject getInstance() {
        return INSTANCE;
    }
}
```



优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。
缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。



**常见案例：**

* Spring 中IOC 容器ApplicationContext 本身就是典型的饿汉式单例



### 懒汉式

懒汉式单例指当被外部类调用的时候内部类才会创建实体。

```java
public class LazySingletonObject {
    // 类加载时立刻初始化并创建单利对象
    private static final LazySingletonObject INSTANCE;
    // 构造函数私有化
    private LazySingletonObject() {}
    public static LazySingletonObject getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new LazySingletonObject();
        }
        return INSTANCE;
    }
}
```

上述代码当在多线程时存在线程安全问题（假如两个线程同时进入if分支里面，有可能导致创建了两次对象）

**解决方案：加锁**

```java
public class LazySingletonObject {
    // 类加载时立刻初始化并创建单利对象
    private static final LazySingletonObject INSTANCE;
    // 构造函数私有化
    private LazySingletonObject() {}
    public synchronized static LazySingletonObject getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new LazySingletonObject();
        }
        return INSTANCE;
    }
}
```

**缺点：**虽然jdk1.6之后对**synchronized**进行了优化，但还是存在性能问题（使用方法时，对整个类进行锁定，其他线程无法获取该锁）

**解决方案：双重判断（方法内部进行加锁）**

```java
public class LazySingletonObject {
    // 类加载时立刻初始化并创建单利对象
    private static final LazySingletonObject INSTANCE;
    // 构造函数私有化
    private LazySingletonObject() {}
    public static LazySingletonObject getInstance() {
        if (INSTANCE == null) {
            synchronized(LazySingletonObject.class) {
                if (INSTANCE == null) {
                    INSTANCE = new LazySingletonObject();
                }
            }
        }
        return INSTANCE;
    }
}
```

**缺点：**由于还是用到的**synchronized**锁，因此还是会造成一定的性能消耗。

### 内部类实现单例

```java
public class LazySingletonObject {
    
    private class LazyInnerSingletonObject {
    	private static final LazySingletonObject INSTANCE = new LazySingletonObject();
    }
    
    // 构造函数私有化
    private LazySingletonObject() {}
    
    public static LazySingletonObject getInstance() {
        return LazyInnerSingletonObject.INSTANCE;
    }
}
```

当调用方法时才会创建单例对象，运用了懒汉式，解决了内存浪费问题。而且由于内部类一定要在方法调用前加载，因此避免了线程安全问题。



### 反射破坏问题

以下通过反射方式创建对象：

```java
//很无聊的情况下，进行破坏
Class<?> clazz = LazyInnerClassSingleton.class;
//通过反射拿到私有的构造方法
Constructor c = clazz.getDeclaredConstructor(null);
//强制访问，强吻，不愿意也要吻
c.setAccessible(true);
//暴力初始化
Object o1 = c.newInstance();
```

可以看出反射创建对象行为会破坏单例。

**解决方案：**

在构造函数直接不允许创建对象

```java
public class LazySingletonObject {
    
    private class LazyInnerSingletonObject {
    	private static final LazySingletonObject INSTANCE = new LazySingletonObject();
    }
    
    // 构造函数私有化
    private LazySingletonObject() {
        // 单例对象一旦创建不允许再创建对象
        if(LazyInnerSingletonObject.INSTANCE != null){
            throw new RuntimeException("不允许创建多个实例");
        }
    }
    
    public static LazySingletonObject getInstance() {
        return LazyInnerSingletonObject.INSTANCE;
    }
}
```



### 序列化破坏问题

由于可以通过序列化的形式将一个对象写入到磁盘中，然而再一次从磁盘中读取对象时，该对象将会是一个新的对象，违背了单例模式。

案例如下：可以得到的结果是序列化后的对象和单例的对象不是同一个对象。

```java
public class SerializeSingletonObject {
    
    private static final SerializeSingletonObject INSTANCE = new SerializeSingletonObject();
    
    // 构造函数私有化
    private SerializeSingletonObject() {
        // 单例对象一旦创建不允许再创建对象
        if(LazyInnerSingletonObject.INSTANCE != null){
            throw new RuntimeException("不允许创建多个实例");
        }
    }
    
    public static LazySingletonObject getInstance() {
        return INSTANCE;
    }
}

public class SeriableSingletonTest {
    public static void main(String[] args) {
        SerializeSingletonObject s1 = null;
        SerializeSingletonObject s2 = SerializeSingletonObject.getInstance();
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream("SerializeSingletonObject.obj");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s2);
            oos.flush();
            oos.close();
            FileInputStream fis = new FileInputStream("SerializeSingletonObject.obj");
            ObjectInputStream ois = new ObjectInputStream(fis);
            s1 = (SerializeSingletonObject)ois.readObject();
            ois.close();
            System.out.println(s1);
            System.out.println(s2);
            System.out.println(s1 == s2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



**解决方案：添加readResolve()方法**

```java
public class SerializeSingletonObject {
    
    private static final SerializeSingletonObject INSTANCE = new SerializeSingletonObject();
    
    // 构造函数私有化
    private SerializeSingletonObject() {
        // 单例对象一旦创建不允许再创建对象
        if(LazyInnerSingletonObject.INSTANCE != null){
            throw new RuntimeException("不允许创建多个实例");
        }
    }
    
    public static LazySingletonObject getInstance() {
        return INSTANCE;
    }
    
    private Object readResolve(){
        return INSTANCE;
    }
}
```

**原理：**

ObjectInputStream 类的readObject()方法实际上底层会判断是否有空构造函数，有就会创建对象，这就是为什么序列化会创建了新的对象。

然后检查序列化对象是否有readResolve方法，有的话会调用该方法并返回。

因此实际上创建了一个新的对象，但只是序列化时调用了readResolve，返回了单例的对象，不是新创建的对象，从而解决序列化破坏单例问题。



### 注册式单例

**注册式单例**又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。

#### 枚举式单例

```java
public enum EnumSingleton {
    INSTANCE;
    private Object data;
    public Object getData() {
        return data;
    }
    public void setData(Object data) {
        this.data = data;
    }
    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}
```

**如何解决线程安全问题？**

我们可以通过**jad反编译工具**反编译该枚举，可以发现实际上枚举会被编译成java类，而该类会有一个静态代码块

```java
static {
    INSTANCE = new EnumSingleton("INSTANCE", 0);
    $VALUE = (new EnumSingletong[] {
        INSTANCE
    });
}
```

可以看出实际上枚举式单例是饿汉式单例的一种实现，因此可以避免线程安全问题。



**如何解决序列化破坏问题？**

从序列化的ObjectInputStream 的readObject方法源码中可以看到，其对枚举类型是通过类名和Class对象类去寻找唯一的枚举对象。而枚举对象不可能被类加载器加载多次，从而解决序列化破坏问题。



**如何解决反射破坏问题？**

从Constructor的newInstance方法源码可以看到，JDK从设计上拒绝枚举类通过反射创建实例。



**因此，综合来说JDK为我们提供了最优雅的单例实现：枚举式单例。**



#### 容器式单例

**容器式单例**适合创建单例实例非常多的情况，最常见为Spring中的容器是单例。

```java
public class ContainerSingleton {
    private ContainerSingleton(){}
    private static Map<String,Object> ioc = new ConcurrentHashMap<String,Object>();
    public static Object getBean(String className){
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object obj = null;
                try {
                    obj = Class.forName(className).newInstance();
                    ioc.put(className, obj);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return obj;
            } else {
                return ioc.get(className);
            }
        }
    }
}
```

虽然使用线程安全集合ConcurrentHashMap确保了多线程下对集合的操作是安全的，不能确保集合外的操作，例如上面代码中赋值给obj操作，因此需要配合**Synchronized**修饰符使用



### ThreadLocal线程单例

ThreadLocal能单独分配线程级的内存空间存储对象，因此天生是线程安全的，但是缺点是线程之间持有的单例互不相等。

```java
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance =
        new ThreadLocal<ThreadLocalSingleton>(){
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };
    private ThreadLocalSingleton(){}
    public static ThreadLocalSingleton getInstance(){
        return threadLocalInstance.get();
    }
}
```

加锁是以时间换取空间从而让单例实现线程安全，而ThreadLocal是以空间换取时间实现线程间的隔离。



## 原型模式

**原型模式**是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**使用场景：**

* 类初始化消耗资源较多。
* new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
* 构造函数比较复杂。
* 循环体中生产大量对象时。



使用案例：

* BeanUtils的copy（浅拷贝）
* JSON的parseObject方法
* Guava

为了方便下面的讲解，定义了一下对象：

```java
public class Person {
    int age;
    String name;
    Address address;
    
    public Person(int age, String name, Address address) {
        this.age = age;
        this.name = name;
        this.address = address;
    }
    // 省略get/set
}
public class Address {
    String area;
    
    public Address (String area) {
        this.area = area;
    }
    // 省略get/set
}
```

### 浅拷贝

将要拷贝的对象的引用赋值给新的变量。例如：

```java
Address address = new Address("GZ")
Person person1 = new Person(20, "Cavie", address);
Person person2 = person1; // 引用变量指向了person1
person1.setAge(21); // person2同时也会修改
```

可见浅拷贝后，原来的对象发生变化，拷贝后的对象也会随之变化。

常见的集合对象 `Map.putAll()`、`List.addAll()` 等都是浅拷贝。



浅拷贝规则：

- 基本类型：例如 int,float等，会复制其值。（因此拷贝后，原来的值改变，也不会影响拷贝后的值）
- 对象：如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。
- String：若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有字符串对象保持不变。



#### Cloneable

Java 默认提供克隆方法 `clone()`，但克隆的对象必须实现 `Cloneable` 标识接口，否则会报 `ClassNotSupportedException` 。

`clone()` 方法默认实现是浅拷贝。



### 深拷贝

深拷贝与浅拷贝的不同处是：不是单纯的拷贝对象的地址引用，而是创建一个新的对象，并拷贝对象中的值。



#### 遍历复制

可以通过逻辑实现深拷贝：

1. new 一个新的对象
2. 将要拷贝的对象中的属性值赋值到新的对象

这种方法麻烦，若集合对象有多少个值，就要遍历多少次。



#### Clone方法

需要覆盖原有的 `clone()` 方法：

```java
public class Address implements Cloneable {
    // 省略，如上
    
    @Override  
    public Object clone() {  
        Address addr = null;  
        try{  
            addr = (Address)super.clone();  
        }catch(CloneNotSupportedException e) {  
            e.printStackTrace();  
        }  
        return addr;  
    }  
}
public class Person implements Cloneable {
    // 省略，如上
    
    @Override  
    public Object clone() {  
        Person person = null;  
        try{  
            person = (Person)super.clone();   //浅复制  
        }catch(CloneNotSupportedException e) {  
            e.printStackTrace();  
        }  
        person.address = (Address)address.clone();   //深度复制  
        return person;  
    }  
}
```

由于 Person 对象中含有 Address 对象，如果是默认的 `clone()` 只会将 Address 对象浅拷贝在 Person 中，因此需要将 Person 中的对象也实现 `clone()` 方法，这样就可以实现 Person 的深拷贝。



#### 序列化

使用序列化将对象写成二进制流，再读取成对象，此时读取的对象是一个新的对象。序列化需要实现 `Serializable` 接口

序列化工具：

```java
public class CloneUtils {
    public static <T extends Serializable> T clone(T obj) {
        T cloneObj = null;
        try {
            //写入字节流
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ObjectOutputStream obs = new ObjectOutputStream(out);
            obs.writeObject(obj);
            obs.close();

            //分配内存，写入原始对象，生成新对象
            ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(ios);
            //返回生成的新对象
            cloneObj = (T) ois.readObject();
            ois.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cloneObj;
    }
}
```

同样序列化拷贝对象时，如果对象包含对象，包含的对象同样也需要实现 `Serializable` 接口。



### 原型模式破坏单例

由于原型模式通过克隆形式会导致创建多个实例对象，违背单例模式。如果我们通过实现Cloneable接口实现克隆，那我们可以通过重写clone方法，让该方法直接返回单例对象，即可避免创建多个实例对象。



## 代理模式

**代理模式**指客户端要通过某个中介（代理）对象才能访问指定对象，其作用是对指定对象进行保护和增强。



常见案例：**SpringAOP**就是使用动态代理模式实现。



客户端调用代理对象方法，实际该方法调用了被代理对象的方法，但是调用被代理对象的方法前/后调用了特定的增强方法，而调用者是无感知的（在调用者看来只是调用了被代理对象的方法）。

**代理模式**分为 `静态代理` 和 `动态代理`。



### 静态代理

```java
public class Son {
    public void findLove(){
        //我没有时间
        //工作忙
        System.out.println("儿子要求：肤白貌美大长腿");
    }
}

public class Father {
    private Son son;
    //没办法扩展
    public Father(Son son){
        this.son = son;
    }
    //目标对象的引用给拿到
    public void findLove(){
        System.out.println("父母物色对象");
        this.son.findLove();
        System.out.println("双方同意交往，确立关系");
    }
}
```

Father可以看成是Son的代理对象，通过 `Father.findLove()` 实际调用被代理对象`Son.findLove()` ，在调用前后增加对应的增强代码。

以上就是静态代理的实现。当我们对`Son.findLove()`进行增强逻辑修改时，我们不需要修改其内部实现，而是从代理对象`Father.findLove()`添加增强逻辑，这样符合开闭原则。



**缺点：**

* 代理对象限制
* 被代理对象的代理方法增加，代理对象也要相应的手动增加代理方法



### 动态代理

**动态代理**是解决静态代理的缺点的一种代理实现方式。其常见的实现方式有两种 **JDK实现**和**CGLib**实现



我们将上述案例修改一下，Father不仅可以代理Son，也可以代理Daughter即子女Child

#### JDK实现

```java
public interface child {
	void findLove();
}

public class Son implements Child {
    public void findLove(){
        //我没有时间
        //工作忙
        System.out.println("儿子要求：肤白貌美大长腿");
    }
}

public class Daughter implements Child {
    public void findLove(){
        //我没有时间
        //工作忙
        System.out.println("女儿要求：帅高大");
    }
}

public class Father implements InvocationHandler {
    private Child child;
    public Object getProxyInstance(Child child){
        this.child = child;
        Class<?> clazz = child.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before(args);
        Object object = method.invoke(child, args);
        after(args);
        return object;
    }

    private void before(Object[] args) {
		System.out.println("被代理对象方法调用前增强");
    }

    private void after(Object[] args) {
		System.out.println("被代理对象方法调用后增强");
    }
}

public static void main(String[] args) {
    try {
        Child child = (Child)new Father().getProxyInstance(new Daughter());
        child.findLove();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

上述代码看似调用了`Daughter.findLove()`，实际执行了以下步骤：

1. 代理对象Father通过JDK提供的Proxy类动态生成代理对象，Proxy原理如下：
   1. 通过传入的被代理对象，反射获取其所有接口；
   2. 重新生成一个新的类，该类实现被代理对象接口的所有方法（实际实现的方法调用了`InvocationHandler.invoke()`，该方法在调用被代理对象原本实现之于外，还增加了自己定义的增强代码）；
   3. 动态生成代码，并编译成新的.class文件；
   4. 将生成的class类加载到JVM中运行。

2. 调用Proxy类动态生成的代理对象（该对象类名为$Proxy0，后面的数字会随着每新增一个代理对象自增）



**JDK 实现要求被代理对象提供接口，并且该接口的方法即为代理的方法。**



#### CGLib实现

```java
public class Son {
    public void findLove(){
        //我没有时间
        //工作忙
        System.out.println("儿子要求：肤白貌美大长腿");
    }
}

public class Daughter {
    public void findLove(){
        //我没有时间
        //工作忙
        System.out.println("女儿要求：帅高大");
    }
}

public class Father implements MethodInterceptor{ {
    public Object getProxyInstance(Class<?> clazz) {
        Enhancer enhancer = new Enhancer();
        //要把哪个设置为即将生成的新类父类
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        //业务的增强
        before();
        Object obj = methodProxy.invokeSuper(o,objects);
        after();
        return obj;
    }

    private void before() {
		System.out.println("被代理对象方法调用前增强");
    }

    private void after() {
		System.out.println("被代理对象方法调用后增强");
    }
}

public static void main(String[] args) {
    try {
        
        //利用cglib 的代理类可以将内存中的class 文件写入本地磁盘
System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,
"E://cglib_proxy_class/");
        
        Daughter daughter = (Daughter)new Father().getProxyInstance(new Daughter());
        daughter.findLove();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

通过设置CGLib动态生成的class文件本地保存可以看到实际原理如下：

1. CGLib会动态生成三个类文件，其中代理类命名为`被代理类名$$EnhancerByCGLIB$$十六进制数.class`
2. 生成的代理类会继承我们指定的被代理对象，并且实现了被代理类的所有方法。
3. 调用代理对象方法时，会调用`intercept()`，进而调用被代理对象的方法增强逻辑以及被代理对象原本实现逻辑。



**CGLib实现比JDK实现执行代理方法效率高**，原因如下：

1. CGLib会为代理类和被代理类个生成一个FastClass，这就是上面提到生成三个class文件的另外两个。
2. 当调用代理类/被代理类的方法时，可以通过FastClass定位到，并直接调用，省去了反射调用，因此执行效率会更高。

FastClass并不是和代理类一起生成的，而是第一次执行MethodProxy.invoke/invokeSuper时生成并缓存下来。



#### CGLib 和 JDK 动态代理对比

1. JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。
2. JDK 和CGLib 都是在运行期生成字节码，JDK 是直接写Class 字节码，CGLib 使用ASM
   框架写Class 字节码，Cglib 代理实现更复杂，生成代理类比JDK 效率低。
3. JDK 调用代理方法，是通过反射机制调用（调用反射类Method），CGLib 是通过FastClass 机制直接调用方法（通过MethodProxy调用FastClass直接定位到方法），CGLib 执行效率更高。



### 静态代理和动态代理区分

1. 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步
   新增，违背开闭原则。
2. 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开
   闭原则。
3. 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，
   无需修改代理类的代码。



### 代理模式优缺点

**优点：**

1. 代理模式能将代理对象与真实被调用的目标对象分离。
2. 一定程度上降低了系统的耦合度，扩展性好。
3. 可以起到保护目标对象的作用。
4. 可以对目标对象的功能增强。



**缺点：**

1. 代理模式会造成系统设计中类的数量增加。
2. 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。
3. 增加了系统的复杂度。



## 策略模式

**策略模式**是指定义了算法家族分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。



**应用场景：**

1. 假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。
2. 一个系统需要动态地在几种算法中选择一种。

**案例：**购买商品有许多支付模式

```java
public interface Payment {
    void pay();
}

public class AliPay implements Payment {
    @Override
    public void pay() {
        System.out.println("支付宝支付");
    }
}

public class WechatPay implements Payment {
    @Override
    public void pay() {
        System.out.println("微信支付");
    }
}

public class Goods {
    public void buy(Payment payment) {
        payStrategy.pay();
    }
}

public static void main() {
    Goods goods = new Goods();
    goods.buy(new AliPay());
}
```

购买商品可以有多种支付手段（每种支付策略作用都是支付，都可以相互替换，只是实现细节不一样），客户端通过传入指定的支付策略即可购买商品。

上述代码实际情境中会根据用户选择不同而选择对应的支付策略：

```java
public interface Paystrategy {
    void pay();
}

public class AliPay implements Paystrategy {
    @Override
    public void pay() {
        System.out.println("支付宝支付");
    }
}

public class WechatPay implements Paystrategy {
    @Override
    public void pay() {
        System.out.println("微信支付");
    }
}

public class PaystrategyFactory {
    private static Map<String, Paystrategy> paystrategyMap = new HashMap<>();
    
    static {
        paystrategy.put(PaystrategyKey.ALIPAY, new AliPay());
        paystrategy.put(PaystrategyKey.WECHAT, new WechatPay());
    }
    
    private PaystrategyFactory {
        
    }
    
    public static Paystrategy getPaystrategy(String paystrategyKey) {
        Paystrategy paystrategy = paystrategyMap.get(paystrategyKey);
        return paystrategy == null ? paystrategyMap.get(PaystrategyKey.NORMALPAY) : paystrategy;
    }
    
    private interface PaystrategyKey {
        String ALIPAY = "ALIPAY";
        String WECHAT = "WECHATPAY";
        String NORMALPAY = ALIPAY;
    }
}

public class Goods {
    public void buy(Paystrategy payStrategy) {
        payStrategy.pay();
    }
}

public static void main() {
    Goods goods = new Goods();
    String paystrategyKey = "ALIPAY";
    goods.buy(PaystrategyFactory.getPaystartegy(paystrategyKey));
}
```

实际情景可能是用户选择不同支付形式，`paystrategyKey`作为参数传入进来，代码实现需要一些列if/else判断应该new哪一种支付策略。而上述实现方式结合了工厂和单例模式，很好的解决了if/else问题，`paystrategyKey`在工厂中获取对应的支付策略。



**策略模式源码使用：**

1. JDK 中的Comparator，我们`Arrays.sort()`、`TreeMap`需要我们将比较器（比较策略）作为参数传入。
2. Spring中Resource和InstantiationStrategy（初始化策略）



### 策略模式优缺点

**优点：**

1. 策略模式符合开闭原则（每增加一种策略，只需新建一个策略类，不需要修改方法）。
2. 避免使用多重条件转移语句，如if...else...语句、switch 语句
3. 使用策略模式可以提高算法的保密性和安全性。

**缺点：**

1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
2. 代码中会产生非常多策略类，增加维护难度。



## 委派模式

**委派模式**基本作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程（对代理方法进行增强），而委派模式注重结果（通过指定的策略获取想要的结果）。

**实际上委派模式可以看成静态代理+策略模式**

案例：SpringMVC中的DispatchServlet（根据客户端的url调用对应的方法处理并返回结果）

以下是粗略实现

```java
public class DispatcherServlet extends HttpServlet{
    private List<Handler> handlerMapping = new ArrayList<Handler>();
    public void init() throws ServletException {
        try {
            // 通过反射获取url对应的Method方法，并封装到Handler存储
            handlerMapping.put(new Handler(...));
        }catch(Exception e){
        }
    }
    private void doDispatch(HttpServletRequest request, HttpServletResponse response){
        //1、获取用户请求的url
        String uri = request.getRequestURI();
        //2、根据用户请求的URL，去找到这个url 对应的某一个java 类的方法,通过拿到的URL 去handlerMapping（我们把它认为是策略常量）
        Handler handle = null;
        for (Handler h: handlerMapping) {
            if(uri.equals(h.getUrl())){
                handle = h;
                break;
            }
        }
        //3、将具体的任务分发给Method（通过反射去调用其对应的方法）
        Object object = null;
        try {
            object =
                handle.getMethod().invoke(handle.getController(),request.getParameter("mid"));
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        //4、获取到Method 执行的结果，通过Response 返回出去
        // response.getWriter().write();
    }

    protected void service(HttpServletRequest req, HttpServletResponse resp) throws
        ServletException, IOException {
        try {
            doDispatch(req,resp);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
      * 用于封装URL及映射的对象和方法
      */
    class Handler{
        private Object controller;
        private Method method;
        private String url;
        public Object getController() {
            return controller;
        }
        public Handler setController(Object controller) {
            this.controller = controller;
            return this;
        }
        public Method getMethod() {
            return method;
        }
        public Handler setMethod(Method method) {
            this.method = method;
            return this;
        }
        public String getUrl() {
            return url;
        }
        public Handler setUrl(String url) {
            this.url = url;
            return this;
        }
    }
}
```

上面实现结合了委派模式、策略模式、单例模式、工厂模式，实现了DispatchServlet的委派功能。



## 模板模式

**模板模式**通常又叫模板方法模式是指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。



**模板模式使用场景：**

1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。



**模板模式和策略模式区别在于：**策略模式一般基于接口（接口提供一个方法，需要策略类去实现），而模板模式一般基于一个抽象类，类中的方法都是**有一定步骤顺序**，其中某些步骤需要子类去实现。



**案例：**

放物品到冰箱，一般分为三个步骤，开冰箱，放东西，关冰箱。假设开关冰箱步骤对于不同的冰箱来说都说相同的操作，只有放东西是多种冰箱各自实现逻辑。

```java
/**
* 模板会有一个或者多个未现实方法，
* 而且这几个未实现方法有固定的执行循序
* Created by Tom.
*/
public abstract class Refridgerator {
    protected final void putThingIn() {
        open();
        put();
        // 钩子方法，假设有的冰箱是自动关闭
        if (!autoClose()) {
            close();
        }
    }
    
    protected final open() {
        System.out.println("打开冰箱");
    }
    
    abstract void put();
    
    protected boolean autoClose() {
        return false;
    }
    
    protected final close() {
        System.out.println("关闭冰箱");
    }
}

public class GeliRefridgerator extends Refridgerator {
    @Override
    public void put() {
        System.out.println("放东西进格力冰箱");
    }
    
    @Override
    protected boolean autoClose() {
        return true;
    }
}
```

实际开发中，一般需要钩子方法（控制某些流程步骤是否需要执行）。



在JDBC中也有用到模板模式**JdbcTemplate**：

```java
// 处理数据库结果集映射成所需对象
public interface RowMapper<T> {
    T mapRow(ResultSet rs, int rowNum) throws Exception;
}

// 模板类，用于从数据库获取数据集并转换成对象结果集
public abstract class JdbcTemplate {
    private DataSource dataSource;
    public JdbcTemplate(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    public List<?> executeQuery(String sql, RowMapper<?> rowMapper, Object[] values){
        try {
            //1、获取连接
            Connection conn = this.getConnection();
            //2、创建语句集
            PreparedStatement pstm = this.createPrepareStatement(conn,sql);
            //3、执行语句集
            ResultSet rs = this.executeQuery(pstm,values);
            //4、处理结果集
            List<?> result = this.paresResultSet(rs,rowMapper);
            //5、关闭结果集
            this.closeResultSet(rs);
            //6、关闭语句集
            this.closeStatement(pstm);
            //7、关闭连接
            this.closeConnection(conn);
            return result;}catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }
    protected void closeConnection(Connection conn) throws Exception {
        // 如果是数据库连接池，我们不需要关闭
        conn.close();
    }
    protected void closeStatement(PreparedStatement pstm) throws Exception {
        pstm.close();
    }
    protected void closeResultSet(ResultSet rs) throws Exception {
        rs.close();
    }
    protected List<?> paresResultSet(ResultSet rs, RowMapper<?> rowMapper) throws Exception {
        List<Object> result = new ArrayList<Object>();
        int rowNum = 1;
        while (rs.next()){
            result.add(rowMapper.mapRow(rs,rowNum ++));
        }
        return result;
    }
    protected ResultSet executeQuery(PreparedStatement pstm, Object[] values) throws Exception {
        for (int i = 0; i < values.length; i++) {
            pstm.setObject(i,values[i]);
        }
        return pstm.executeQuery();
    }
    protected PreparedStatement createPrepareStatement(Connection conn, String sql) throws Exception
    {
        return conn.prepareStatement(sql);
    }
    public Connection getConnection() throws Exception {
        return this.dataSource.getConnection();
    }
}

public class User {
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }
    public void setAge() {
        this.age = age;
    }
}

public class UserDao extends JdbcTemplate {
    public UserDao(DataSource dataSource) {
        super(dataSource);
    }
    public List<?> selectAll(){
        String sql = "select * from t_user";
        return super.executeQuery(sql, new RowMapper<Member>() {
            public User mapRow(ResultSet rs, int rowNum) throws Exception {
                User user = new User();
                //字段过多，原型模式
                user.setUsername(rs.getString("username"));
                user.setAge(rs.getInt("age"));
                return user;
            }},null);
    }
}
```

JdbcTemplate 模板类省略了数据库连接、语句集等操作，只需用户实现如何将获取到数据库结果集映射到我们所需对象的逻辑即可。

**日常使用源码：**

* JDK 中的`AbstractList`同样也是模板类，其中的get方法就是一个抽象方法由其子类实现。
* **HttpServlet**，其中的 `service()` 和`doGet()` 、`doPost()`方法，都是模板方法的抽象实
  现。
* **MyBatis** 的BaseExecutor 类，它是一个基础的SQL 执行类，实现了大部分的SQL 执行逻辑，然后把几个方法交给子类定制化完成。



### 模板模式优缺点

**优点：**

1. 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。
2. 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。
3. 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，
   符合开闭原则。



**缺点：**

1. 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。
2. 类数量的增加，间接地增加了系统实现的复杂度。
3. 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。



## 适配器模式

**适配器模式**是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作。

**适配器使用场景：**

1. 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。
2. 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不
   同厂家造成功能类似而接口不相同情况下的解决方案。

我们可以从生活中最常见的充电适配器作为参考，我们插头电压是220V，但我们手机充电可能只能支持5V电压，因此需要一个中介的东西，将220V电压转换成5V，这样才能给手机充电。（此处最原始设计时，只考虑到220V的规定，但是随着后面发展，出现了手机产品，手机产品的充电电压并不适合以前的电压标准规则，因此才需要电源适配器作为转换电压的中介）

**案例：**兼容旧的登陆标准，用适配器将旧的登录标准转成新的登陆标准。

```java
public class ResultMsg {
    private int code;
    private String msg;
    private Object data;
    public ResultMsg(int code, String msg, Object data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }
    public int getCode() {
        return code;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public String getMsg() {
        return msg;
    }
    public void setMsg(String msg) {
        this.msg = msg;
    }
    public Object getData() {
        return data;
    }
    public void setData(Object data) {
        this.data = data;
    }
}
// 旧的登陆标准
public class SiginService {
    /**
     * 注册方法
     */
    public ResultMsg regist(String username,String password){
        return new ResultMsg(200,"注册成功",new Member());
    }
    /**
	/**
     * 登陆方法
     */
    public ResultMsg login(String username,String password){
        return null;
    }
}

// 可有可无，抽象出来适配器方法，代码规范
public interface LoginAdapter {
    // 钩子方法，用来是否支持适配
    boolean support(Object adapter);
    ResultMsg login(Object[] args,Object adapter);
}

// 根据新的不同登陆规则实现对应的适配器
public class LoginForQQAdapter implements LoginAdapter {
    public boolean support(Object adapter) {
        return adapter instanceof LoginForQQAdapter;
    }
    public ResultMsg login(Object[] args, Object adapter) {21
        return null;
                                                      }
}

public class LoginForWechatAdapter implements LoginAdapter {
    public boolean support(Object adapter) {
        return adapter instanceof LoginForWechatAdapter;
    }
    public ResultMsg login(Object[] args, Object adapter) {
        return null;
    }
}


public class PassportForThirdAdapter extends SiginService {
    // 这里用到了简单工厂模式及策略模式
    private ResultMsg processLogin(Object[] args,Class<? extends LoginAdapter> clazz){
        try {
            LoginAdapter adapter = clazz.newInstance();
            if(adapter.support(adapter)) {
                // 调用新的准则
                adapter.login(args, adapter);
                // 调用原来的准则
                return super.login(username,null);
            }else {
                return null;
            }
        }catch (Exception e){
            e.printStackTrace();;
        }
        return null;
    }
}
```

上面代码可能场景为，原本自己有一套登陆实现，现在要求接入其他平台，需要添加其他平台的登陆规则。因此我们设计了一个第三方适配器，利用了策略模式、简单工厂模式和适配器模式，根据不同的第三方，调用其适配器的登陆方法，最后调用会自己的登陆实现。通过该适配器，很好地兼容了第三方登陆标准和自己的登陆标准。



类似的还有：

1. SpringAOP 中的 `AdvisorAdapter` 类，它有三个实现类 `MethodBeforeAdviceAdapter`、`AfterReturningAdviceAdapter` 和 `ThrowsAdviceAdapterSpring` 会根据不同的AOP 配置来确定使用对应的Advice，跟策略模式不同的是一个方法可以同时拥有多个Advice，策略模式只能有一个。
2. SpringMVC 中的 `HandlerAdapter` 类，其适配调用的关键代码还是在 `DispatcherServlet` 的`doDispatch()` 方法中。



### 适配器模式的优缺点
**优点：**

1. 能提高类的透明性和复用，现有的类复用但不需要改变。
2. 目标类和适配器类解耦，提高程序的扩展性。
3. 在很多业务场景中符合开闭原则。



**缺点：**

1. 适配器编写过程需要全面考虑，可能会增加系统的复杂性。
2. 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。



## 装饰器模式

**装饰者模式**是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）。



**适用场景：**

1. 用于扩展一个类的功能或给一个类添加附加职责。
2. 动态的给一个对象添加功能，这些功能可以再动态的撤销。



案例：煎饼，我们可以在饼上加鸡蛋，加肉等材料。加完后材料后还是一个煎饼。

```java
public abstract BaseCake {
    int getPrice();
}

public class PanCake extends BaseCake {
    @Override
    public int getPrice() {
        return 5;
    }
}
```

我们创建抽闲类饼（抽象出饼的基本信息），煎饼是其中一种实现类。上述需求最简单的实现方式是通过继承，创建子类：

```java
public class PanCakeWithEgg extends PanCake {
    @Override
    public int getPrice() {
        return super.getPrice() + 1;
    }
}

public class PanCakeWithMeat extends PanCake {
    @Override
    public int getPrice() {
        return super.getPrice() + 2;
    }
}
```

但此时如果我们有特殊需求，例如加两个蛋，那我们就需要再创建一个子类，显然加蛋、加肉等只是一种修饰，用来修饰我们的饼。我们用装饰者模式重新实现：

```java
// 饼装饰器抽象类，对传入的baseCake（饼）进行装饰
public abstract class PancakeDecorator extends BaseCake {
    // 实际上也是一种静态代理模式
    private BaseCake baseCake;
    public PancakeDecorator(BaseCake baseCake) {
        this.baseCake = baseCake;
    }
    protected abstract void doSomething();

    @Override
    protected int getPrice() {
        return this.baseCake.getPrice();
    }
}

public class EggDecorator extends PancakeDecorator {
    public EggDecorator(BaseCake baseCake) {
        super(baseCake);
    }
    protected void doSomething() {}
    
    @Override
    protected int getPrice() {
        return super.getPrice() + 1;
    }
}

public class MeatDecorator extends PancakeDecorator {
    public MeatDecorator(BaseCake baseCake) {
        super(baseCake);
    }
    protected void doSomething() {}
    
    @Override
    protected int getPrice() {
        return super.getPrice() + 2;
    }
}

// 测试方法
public static void main(String[] args)) {
    BaseCake cake;
    cake = new PanCake()
    // 加两次蛋
    cake = new EggDecorator(cake);
    cake = new EggDecorator(cake)
}
```

从上面的实现可以看出，我们需要加多少个蛋、多少次肉，只需要包裹对应装饰器即可，而不需要去对特定需求不断地添加子类。



### 装饰者模式和适配器模式区别

装饰者和适配器模式都是包装模式，装饰者也是一种特殊的代理模式。

|      | 装饰者模式                                                   | 适配器模式                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 形式 | 适配器模式特殊实现                                           | 没有层级关系，装饰器模式有层级关系（装饰器可以包裹起来）     |
| 定义 | 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留OOP 关系 | 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 |
| 关系 | is-a 关系                                                    | 满足has-a 的关系（持有被适配者的对象，并用来转换成支持新的接口） |
| 功能 | 注重覆盖、扩展                                               | 注重兼容、转换                                               |
| 设计 | 前置考虑（开发的时候）                                       | 后置考虑（开发完后，出现新的需求，旧的接口与新的接口不匹配，需要通过适配器进行转换） |



### 源码中的应用

1. JDK 中IO 相关的类，如 `BufferedReader`、`InputStream`、`OutputStream`，基本都是通过传入`InputStream` 对象进行装饰。
2. Spring 中的 `TransactionAwareCacheDecorator` 是对 `Cache` 对象进行装饰（添加了事务功能）。



### 装饰者模式的优缺点

**优点：**

1. 装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象

   扩展功能，即插即用。

2. 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。

3. 装饰者完全遵守开闭原则。



**缺点：**

1. 会出现更多的代码，更多的类，增加程序复杂性。
2. 动态装饰时，多层装饰时会更复杂。



## 观察者模式

**观察者模式**定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主体对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。观察者模式有时也叫做发布订阅模式。观察者模式主要用于在关联行为之间建立一套触发机制的场景。

生活中最常见的是邮件通知等一些广播行为。

案例：点击鼠标时，会触发相关监听了鼠标点击事件的观察者。以下基于JDK提供的 `Observable` API 实现。

```java
// 鼠标，被观察者
public Class Mouse extends Observable {
    public void onClick(){
        System.out.println("鼠标被点击");
        // 设置变动
        setChanged();
        // 触发所有观察者
        notifyObservers(null);
    }
}

public class Icon implements Observer {
    private String iconName;
    public Icon(String iconName){
        this.iconName = iconName;
    }
    public void update(Observable o, Object arg) {
        System.out.println("点击鼠标触发Icon：" + this.iconName + "打开");
    }
}
// 测试方法
public static void main(String[] args)) {
    Mouse mouse = new Mouse();
    Icon icon = new Icon("icon1");
    // 对被观察者mouse添加观察者icon
    mouse.addObserver(icon);
    
    mouse.onClick();
}
```

从源码可以看到`Observable`里面有一个集合，用于存储观察者对象。当调用`notifyObservers()`方法是会触发所有观察者，并调用观察者提供的`update()`方法。

```java
public class Observable {
    private boolean changed = false;
    private Vector<Observer> obs;

    public Observable() {
        obs = new Vector<>();
    }

    public synchronized void addObserver(Observer o) {
        if (o == null)
            throw new NullPointerException();
        if (!obs.contains(o)) {
            obs.addElement(o);
        }
    }
    
    public void notifyObservers() {
        notifyObservers(null);
    }

    public void notifyObservers(Object arg) {
        Object[] arrLocal;

        synchronized (this) {
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
    }
}
```

我们常见的Listener一般都是观察者模式。

另一种写法：

```java
/**
* 监听器，它就是观察者的桥梁
* Created by Tom.
*/
public class EventLisenter {//JDK 底层的Lisenter 通常也是这样来设计的
    protected Map<String,Event> events = new HashMap<String,Event>();
    //事件名称和一个目标对象来触发事件
    public void addLisenter(String eventType,Object target){
        try {
            this.addLisenter(
                eventType,
                target,
                target.getClass().getMethod("on" + toUpperFirstCase(eventType),Event.class));
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    public void addLisenter(String eventType,Object target,Method callback){
        //注册事件
        events.put(eventType, new Event(target, callback));
    }
    //触发，只要有动作就触发
    private void trigger(Event event) {
        event.setSource(this);
        event.setTime(System.currentTimeMillis());
        try {
            //发起回调
            if(event.getCallback() != null){
                //用反射调用它的回调函数
                event.getCallback().invoke(event.getTarget(),event);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    //事件名称触发
    protected void trigger(String trigger){
        if(!this.events.containsKey(trigger)){return;}
        trigger(this.events.get(trigger).setTrigger(trigger));
    }
    //逻辑处理的私有方法，首字母大写
    private String toUpperFirstCase(String str){
        char[] chars = str.toCharArray();
        chars[0] -= 32;
        return String.valueOf(chars);
    }
}

public interface MouseEventType {
    //单击
    String ON_CLICK = "click";
}
// 鼠标，监听者
public Class Mouse extends EventLisenter {
    // 当点击鼠标时会触发点击鼠标事件，并触发对应所有监听该事件的对象，触发他们的逻辑
    public void click(){
        System.out.println("调用单击方法");
        this.trigger(MouseEventType.ON_CLICK);
    }
}

public class MouseEventCallback {
    public void onClick(Event e){
        System.out.println("===========触发鼠标单击事件==========" + "\n" + e);
    }
}

// 测试方法
public static void main(String[] args)) {
    MouseEventCallback callback = new MouseEventCallback();
    //注册事件
    Mouse mouse = new Mouse();
    mouse.addLisenter(MouseEventType.ON_CLICK, callback);
}
```



### 源码中的应用

Spring 中的 `ContextLoaderListener` 实现了 `ServletContextListener` 接口，
`ServletContextListener` 接口又继承了 `EventListener`。



### 基于Guava API 实现观察者模式
```java
public class GuavaEvent {
    @Subscribe
    public void subscribe(String str){
        //业务逻辑
        System.out.println("执行subscribe 方法,传入的参数是:" + str);
    }
}

// 测试方法
public static void main(String[] args) {
    EventBus eventbus = new EventBus();
    GuavaEvent guavaEvent = new GuavaEvent();
    // 注册监听者
    eventbus.register(guavaEvent);
    // 发布事件，根据参数来调用对应触发的那个方法
    eventbus.post("Guava");
}
```

### 观察者模式的优缺点

**优点：**

1. 观察者和被观察者之间建立了一个抽象的耦合。
2. 观察者模式支持广播通信。



**缺点：**

1. 观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。
2. 使用要得当，要避免循环调用。



## 设计模式之间的区别

![设计模式区别](C:\Users\63190\Desktop\pics\设计模式区别.jpg)

### 单例模式和工厂模式

实际业务代码中，通常会把工厂类设计为单例。



### 策略模式和工厂模式

1. 工厂模式包含工厂方法模式和抽象工厂模式是创建型模式，策略模式属于行为型模
   式。
2. 工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象（调用传入的对象方法），从而实现不同的行为。



### 策略模式和委派模式

1. 策略模式是委派模式内部的一种实现形式，策略模式关注的是策略算法是否能替换。
2. 委派模式更关注对传入的对象进行分发和调度的过程。



### 模板方法模式和工厂方法模式
工厂方法是模板方法的一种特殊实现。

工厂方法一般只提供创建对象的方法，提供的方法并没有顺序规定。而模板方法提供了部分方法，这些方法实现细节由子类实现，并且方法是有序的。



### 模板方法模式和策略模式

1. 模板方法和策略模式都有封装算法。
2. 策略模式是使不同算法可以相互替换，且不影响客户端应用层的使用。
3. 模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现。
4. 模板方法模式不能改变算法流程，策略模式可以改变算法流程且可替换。策略模式通常用来代替if...else...等条件分支语句。

例如之前的支付方式，他是一种策略，我们可以随意传入想要的支付方式去替换。但它的一些其他方法并不要求一定要去调用。而模板模式不一样，例如上面的放东西去冰箱，规定放东西操作前一定要开冰箱操作。



### 装饰者模式和静态代理模式
1. 装饰者模式关注点在于给对象动态添加方法，而代理更加注重控制对对象的访问。
2. 代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰者作
   为构造参数。



###  装饰者模式和适配器模式

1. 装饰者模式和适配器模式都是属于包装器模式（Wrapper Pattern）。
2. 装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配
   器和被适配者可以实现不同的接口。

他们都可以持有被包装对象，但装饰者是is-a关系，适配器是has-a关系。

### 适配器模式和静态代理模式
适配器可以结合静态代理来实现，保存被适配对象的引用，但不是唯一的实现方式。

### 适配器模式和策略模式
在适配业务复杂的情况下，利用策略模式优化动态适配逻辑。



## 总结

| 设计模式                | 总结                                             | 案例                                                |
| ----------------------- | ------------------------------------------------ | --------------------------------------------------- |
| 工厂模式（Factory）     | 只对结果负责，封装创建过程。                     | BeanFactory、Calender                               |
| 单例模式（Singleton）   | 保证独一无二。                                   | ApplicationContext、Calender                        |
| 原型模式（Prototype）   | 拔一根猴毛，吹出千万个。                         | ArrayList、PrototypeBean                            |
| 代理模式（Proxy）       | 找人办事，增强职责。                             | ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy |
| 委派模式（Delegate）    | 干活算你的（普通员工），功劳算我的（项目经理）。 | DispatcherServlet、BeanDefinitionParserDelegate     |
| 策略模式（Strategy）    | 用户选择，结果统一。                             | InstantiationStrategy                               |
| 模板模式（Template）    | 流程标准化，自己实现定制。                       | JdbcTemplate、HttpServlet                           |
| 适配器模式（Adapter）   | 兼容转换头。                                     | AdvisorAdapter、HandlerAdapter                      |
| 装饰器模式（Decorator） | 包装，同宗同源。                                 | BufferedReader、InputStream                         |

