# 单元测试

单元测试分为两类：**联合型**和**孤立型**。

这两种类型的区别主要在于单元测试**是否和其他底层协作者隔离**。这两种类型并不是互斥的，它们可以很好地互相补充。

联合型单元测试和孤立型单元测试的最大区别在于测试替身的使用，对于联合型单元测试来说，依赖（和协作者）的测试替身是真实的类。

## 孤立型单元测试

　　孤立型单元测试主要关注一个单独对象类的交互。这种测试应该只包括这个类自己的依赖。（如持久化实体）

　　需要测试这个类的所有方法，但是不需要跨越边界进入其他类。通常来讲，这意味着你需要将可能的返回结果注入到插桩或模拟的实现中。这样做的一个主要目的是尽可能提高被测类的代码覆盖率。

　　孤立型单元测试对于那些依赖于物理网络连接、数据库、邮件服务，甚至另一个微服务的场景十分有用。在这些场景下使用一个真实的依赖有以下两个缺点：

* 访问I/O通常是一个相对比较慢的操作，而单元测试应该尽可能地快。

* 远程服务可能会出现故障（服务器宕机、网络故障、防火墙规则等），这也就意味着即使代码正确，测试也可能会出错。



### 使用场景

因此在下面几个场景中，你应该优先考虑孤立型单元测试：

* 单元测试的协作者响应很慢的情况—这可能是由于I/O访问，或者计算本身需要大量时间造成的。

* 单元测试的协作者的逻辑经常变化—这种情况下导致测试失败，可能是协作者的问题而不是被测代码的问题。

* 你想测试一个在正常情况下很难出现的极端情况—例如，测试磁盘空间被用尽的情况。



## 联合型单元测试

　　联合型单元测试主要通过观察模块状态的变化来测试模块的行为。这种方式将被测单元当成一个黑盒，因此十分适用于联合型单元测试盒，完全通过对外的接口进行测试。业务领域组件由于需要和其他部分进行协作来处理请求并返回响因此十分适用于联合型单元测试。

　　在测试中你可能仍需要对某些复杂的协作者类进行插桩或模拟，但需要在离协作对象的层级尽可能远的地方进行这些模拟。你不仅要测试一个类发送和接收的数据是否正确，还需要确保类中的协作者按照预期的方式进行工作。在理想情况下，测试需要覆盖所有的模型、变量以及协作者类。测试这个类是很重要。

　　联合型单元测试通过观察状态的变化来关注被测类在与依赖和协作者共同工作下的行为。很显然，在这种方式下你需要将被测单元当作一个表面的接口，并给接口提供输入。接下来被测单元调用协作者计算出输出，最终利用断言来校验输出结果。

　　联合型单元测试十分适用于测试业务领域的逻辑。
