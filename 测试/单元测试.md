## 单元测试介绍

单元测试是编写测试代码，用来检测特定的、明确的、细颗粒的功能。**单元测试并不一定保证程序功能是正确的，更不保证整体业务是准备的。**

单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码**修复**、**改进**或**重构**之后的正确性。



## 单元测试内容

* **接口功能测试**：用来保证接口功能的正确性。
* **局部数据结构测试**（不常用）：用来保证接口中的数据结构是正确的
  * 比如变量有无初始值
  * 变量是否溢出

* **边界条件测试**
  * 变量没有赋值（即为NULL）
  * 变量是数值（或字符)
    * 主要边界：最小值，最大值，无穷大（对于DOUBLE等）
    * 溢出边界（期望异常或拒绝服务）：最小值-1，最大值+1
    * 临近边界：最小值+1，最大值-1
  * 变量是字符串
    * 引用“字符变量”的边界
    * 空字符串
    * 对字符串长度应用“数值变量”的边界
  * 变量是集合
    * 空集合
    * 对集合的大小应用“数值变量”的边界
    * 调整次序：升序、降序
  * 变量有规律
    * 比如对于Math.sqrt，给出n^2-1，和n^2+1的边界
    * 所有独立执行通路测试：保证每一条代码，每个分支都经过测试

* **代码覆盖率**
  * 语句覆盖：保证每一个语句都执行到了
  * 判定覆盖（分支覆盖）：保证每一个分支都执行到
  * 条件覆盖：保证每一个条件都覆盖到true和false（即if、while中的条件语句）
  * 路径覆盖：保证每一个路径都覆盖到

* **各条错误处理通路测试**：保证每一个异常都经过测试



## JUnit4

JUnit是Java单元测试框架，已经在Eclipse中默认安装。目前主流的有JUnit3和JUnit4。JUnit3中，测试用例需要继承`TestCase`类。JUnit4中，测试用例无需继承`TestCase`类，只需要使用`@Test`等注解。



JUnit4通过注解的方式来识别测试方法。目前支持的主要注解有：

- `@BeforeClass` ：针对所有测试，也就是整个测试类中，在所有测试方法执行前，都会先执行由它注解的方法，**而且只执行一次**。
- `@Before` ：初始化方法，在任何一个测试方法执行之前，必须执行的代码。在该注解的方法中，可以进行一些准备工作，比如初始化对象，打开网络连接等。
- `@Test` ：测试方法。
  - 名字可以随便取，没有任何限制，但是返回值必须为 void ，而且不能有任何参数。如果违反这些规定，会在运行时抛出一个异常。不过，为了培养一个好的编程习惯，我们一般在测试的方法名上加 test ，比如：testAdd（）。
  - 同时，该 Annotation（@Test） 还可以测试期望异常和超时时间，如 @Test（timeout=100），我们给测试函数设定一个执行时间，超过这个时间（100毫秒），他们就会被系统强行终止，并且系统还会向你汇报该函数结束的原因是因为超时，这样你就可以发现这些 bug 了。而且，它还可以测试期望的异常，例如，我们刚刚的那个空指针异常就可以这样：@Test(expected=NullPointerException.class)。
- `@After` ：释放资源，在任何一个测试方法执行之后，需要进行的收尾工作。
- `@AfterClass` ：针对所有测试，也就是整个测试类中，在所有测试方法都执行完之后，才会执行由它注解的方法，**而且只执行一次**。
- `@Ignore` 忽略此方法



## Mock

在做单元测试的时候，我们会发现我们要测试的方法会引用很多外部依赖的对象，比如：（发送邮件，网络通讯，记录Log, 文件系统之类的）。 而我们没法控制这些外部依赖的对象。  为了解决这个问题，我们**需要用到Stub和Mock来模拟这些外部依赖的对象**,**从而控制它们。**

JUnit 是单元测试框架，可以轻松的完成关联依赖关系少或者比较简单的类的单元测试，但是对于关联到其它比较复杂的类或对运行环境有要求的类的单元测试，模拟环境或者配置环境会非常耗时，实施单元测试比较困难。而这些**“mock框架”**（**Mockito 、jmock 、 powermock、EasyMock**），可以通过mock框架模拟一个对象的行为，从而隔离开我们不关心的其他对象，使得测试变得简单。（例如service调用dao，即service依赖dao，我们可以通过mock dao来模拟真实的dao调用，从而能达到测试service的目的。）

模拟对象（Mock Object）可以取代真实对象的位置，用于测试一些与真实对象进行交互或依赖于真实对象的功能，模拟对象的背后目的就是创建一个轻量级的、可控制的对象来代替测试中需要的真实对象，模拟真实对象的行为和功能。



### 何时使用Mock

* 真实对象的行为具有不确定性。
* 真实对象难以创建。
* 真实对象的行为难以模拟(例如网络错误)。
* 真实对象运行效率很低。
* 真实对象有或者是UI。
* 测试需要得到某个对象列表，但是真实对象必须在某种环境下才能提供。
* 真实对象还没实现。



### Mock的优点：
​	运行速度快，测试覆盖率高，容易实现且可以形成良好的测试文档。

### Mock的缺点：

​	不是银弹，对于集成测试等粗粒度且耗时的测试不太适用。



### Mockito

Mockito 是 Google code 的开源项目，其开发api简单，

例子：

```java
public class UserManagerMockitoTest {
	@Test
	public void testGetCityCode(){
		AddressService as = Mockito.mock(AddressService.class);
		Mockito.when(as.findAddress("yld")).thenReturn("nanjing");
		UserManager um = new UserManager();
		um.addressService = as;
		assertEquals(1,um.getCityCode("yld"));
		verify(as,times(1)).findAddress("yld");
	}
}
```



# 测试步骤

## 1.导入Jar包

导入 Junit4 的 Jar 包。

```xml
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
```



## 2.创建 Source Folder

一般项目中的测试类都会放在 `src/test/java` 中



## 3.测试类命名

一般测试 `A.java` 时，则测试类应命名为 `ATest.java`



## 4. 测试方法

* 测试方法需要用 `@Test` 标识
* 测试 `functionA()` 方法时，应当将测试方法命名为 `testFunctionA()`
* 测试方法返回参数要为 void

例：

```java
@Test
public void testFunctionA() {
    ...
}
```



## 5.断言 assert

Junit 提供一系列 assertxxx() 用于判断调试结果是否与预期的一致。



## 6.可重复执行

在 Spring 框架下，如果测试的仿佛涉及数据库，为了保持可持续执行，应当加上事务回滚，使数据不修改数据库。

```java
@TransactionConfiguration(defaultRollback=true)
@Transactional
```



## 7.多线程测试

* 由于 Test 方法相当于一个主线程，所以存在主线程直接执行完后被kill掉，其他线程的代码没有被执行。因此适当的在 Test 方法调用 sleep() 方法进行睡眠确保其他线程执行。 
* Transaction 事务只能控制 Test 方法的主线程回滚，其他线程的事务无法控制，因此可以通过 @After 方法，逻辑的调用 Dao 方法删除影响的数据。（此时需要把 @Transaction 去掉）



## 8.外部依赖（第三方服务、微服务框架）

当测试的方法需要依赖外部项目的类时，此时不应该为此而启动外部项目，而是应该引入外部项目的接口包，自己实现所需要的类的接口（即创建所需类的mock类）。



## 9.单元测试覆盖率

可以使用 Eclipse 自带的 Coverage As 工具测试，或者使用 Jacoco 插件配合 Sonar 使用测试出单元测试覆盖率。

测试出的结果分三种情况：

* 红色部分代码表示没有被测试到
* 黄色部分代表该分支没有被测试全
* 绿色代表代码测测试到

