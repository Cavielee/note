

# CPU负载过高调优

## 定位

定位问题步骤如下：

1. 使用 `top` 命令查看那些进程的 CPU 使用率高，并获取该进程的 pid。
2. 然后再次使用 `top -p 进程ID` 查看具体进程的使用情况。
3. 在第二步的基础上输入 H 可以查看当前线程下所有线程信息。
4. 查找 CPU 使用率高的线程 ID，并将其转换为16进制值。
5. 通过 `jstack 进程 ID` 查看所有线程信息，并且找到第四步获取到使用率高的线程（根据16进制值）
6. 分析对应的线程内容



## 分析

一般 CPU 负载过高有以下原因：



### 用户请求过多

通过 jstack 如果发现创建过多的用户请求处理线程，意味着 QPS 过高。

解决方案：可以考虑集群部署，从而减低单点 QPS。



### 业务线程

通过 jstack 可以进一步分析 CPU 负载高的业务线程在执行那些代码，一般有几种常见的情况：

1. 空轮询。可以增加标志位，避免空轮询，或者改成定时执行。
2. 业务处理时间长。可以将一些无关耗时的操作异步处理，如放到消息队列，从而加快业务处理。
3. 死循环。



### GC 频繁

GC 线程导致 CPU 负载过高，意味着 GC 频繁。

从上面 top 命令的操作，如果分析出是 GC 线程导致 CPU 负载过高，可以通过 jstat 进一步分析：

通过 `jstat -gc pid [interval]` 分析 GC 相关数据，如果 Full GC 频繁，一般为内存泄露，此时需要分析内存情况，分析前需要做一下准备：

1. 通过 `jstack pid > jstack.log` 保存了线程栈的现场。
2. 使用 `jmap -dump:format=b,file=heap.log pid` 保存堆现场。

通过 MAT 工具对 dump 内存快照进行分析，具体可以看 JVM 优化笔记。

解决方案：

1. 如果内存使用合理，可以考虑增加内存。
2. 对于一些数据缓存，如果使用完没有用，应该注意清除掉（如集合中的数据）。
3. 内存泄露。
4. 对一些不影响系统正常运行的数据可以设置为弱引用，从而避免 Full GC。
5. 使用合适的垃圾回收器。



## 总结

![JVM 调优指南](https://raw.githubusercontent.com/Cavielee/notePics/main/JVM 调优指南.jpg)

