# Spring

1. IOC 容器初始化可以总结为以下步骤：

   1. 初始化的入口在容器实现中的 refresh() 调用来完成。
   2. 使用 ResourceLoader 对 Bean 配置进行定位（容器本身就继承了 ResourceLoader 的默认实现DefaultResourceLoader），并加载配置资源 Resource。
   3. 使用 BeanDefinitionReader （如 xml 使用 XmlBeanDefinitionReader，注解使用 AnnotatedBeanDefinitionReader）将上一步加载的 Resource 解析成 BeanDefinition（Spring Bean 的定义） 并注册到 IOC 容器中（容器持有 BeanFactory 的默认实现类 DefaultListableBeanFactory），实际上就是使用一个 HashMap 去存储 BeanName 和对应的 BeanDefinition。
   4. 容器本身就是一个 BeanFactory，其定义了对 Bean 的获取等操作接口，最终调用的是容器本身持有的 BeanFactory 的子类 DefaultListableBeanFactory 的方法实现。




2. 实例化和注入
   1. 对于不是懒加载且 Singleton 模式的 Bean 会在初始化时实例化，而如果是懒加载（默认）的 Bean 则在 getBean() 时才会实例化 Bean。
   2. getBean() 作为实例化入口，首先会在 IOC 容器缓存中获取，没有则往父级容器缓存中尝试获取。
   3. 如果缓存都没有则实例化 Bean，实例化前先对依赖的（dependsOn）Bean 实例化，即对其调用 getBean()方法。若有循环依赖则会报错。
   4. 根据创建模式，如 singleton、prototype等创建其实例，实际调用AbstractAutowireCapableBeanFactory.createBeanInstance() 实例化对象。
   5. 根据不同的初始化策略实例化 Bean 对象。
   6. 使用 JDK 的反射方法或者 CGLib方式实例化对象。
   7. 创建后的实例对象（Singleton 模式）先将引用缓存到 IOC 容器中。
   8. 根据属性类型进行值转换。
   9. 根据属性类型进行值注入。



3. AOP

   1. 根据 AOP 配置判断是否有 Advisor 符合 Bean，如果有就选择对应的策略（JDK 动态代理/CGLib 动态代理）创建代理对象。
   2. 调用代理对象方法时，获得该方法的拦截器链，通过拦截器链触发通知执行。

4. Spring MVC

   1. Spring MVC 自带 Web 容器，程序员开发时不需要单独将工程部署到 Web 容器上，直接运行 Spring MVC 项目即可运行 Web 服务。
   2. Spring MVC 对 Web 架构进行分层模型，主要分为三层：Controller 层（用于定义 Web 服务接口，即常见的一个 url 对应一个接口方法），Service 层（具体的业务逻辑），DAO 层（操作数据库）。
   3. Spring MVC 提供核心类 DispatcherServlet，其实现 HttpServlet。开发时只需在配置该 DispatcherServlet 的具体实现类即可。客户端访问时，会由底层的 Web 容器封装对应的 Request/Response 传到 DispatcherServlet，并由 DispatcherServlet 作为调度器调度一系列组件进行处理。
   4. DispatcherServlet 首先调度 HandlerMapping，找到请求 url 对应的执行链（handler 和 interceptor）。
   5. DispatcherServlet 将第四步获得的执行链交给 HandlerAdapter 进行处理，HandlerAdapter 将请求数据适配转换成方法所需参数，并调用方法。
   6. DispatcherServlet 将方法处理完后会返回视图数据交给对应的 ViewResolver  解析成 View，最终通过 View 进行视图数据渲染返回给客户端。

5. jdk 和 cglib动态代理

   aop实现原理，以及jdk动态代理会遇到的问题？
   在spring中会有两种方式实现动态代理。
   分别是jdk提供的和cglib，spring默认使用jdk实现，但是jdk是基于接口实现，动态代理的方法需要在接口中定义。因此会存在问题:如果代理类没有接口实现，就不能进行动态代理。
   那cglib就没有什么问题了吗？
   而cglib是基于继承的形式，动态生成代理类的子类字节码文件。因此存在问题:如果类是final就不能使用cglib
   因此我们一般推荐面向接口编程



6. PrepareStatement 好处

   1. 批量操作时可以利用 PrepareStatement 的预编译特性，从而避免多次编译，导致执行效率慢。
   2. 参数占位符，提供占位符的机制，避免编写多次重复语句。
   3. 防止 SQL 注入。因为参数是作为 String 解析，而不会经历编译阶段。

7. jdbc

   使用传统的 JDBC 编写数据库操作时需要以下步骤：

   1. 加载驱动程序
   2. 获得数据库连接
   3. 操作数据库，实现增删改查
   4. 获取结果集并遍历结果
   5. 关闭ResultSet、Statement、Connection资源

   当然使用数据库连接池可以节省为：

   1. 从 DataSource 获取连接
   2. 操作数据库，实现增删改查
   3. 获取结果集并遍历结果

# 网络

2. http1.0 1.1 2.0区别

3. http https区别

4. 怎么实现长连接

5. 长连接用的什么字段

6. http报文包含什么

7. http有哪些状态码

8. tcp三次握手

9. tcp的拥塞控制

10. tcp有什么缺点

11. 提高传输速率还有什么解决办法

12. udp如果要实现可靠怎么办

13. http请求有哪几种

14. OSI七层

    1. 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
    2. 表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。
    3. 会话层：建立及管理会话。

    > 由于表示层和会话层一般交给程序开发去定义具体的实现，因此也可以归结为应用层内容。

    4. 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
    5. 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
    6. 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。
    7. 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

15. 应用层还有啥协议

16. cookie和session区别
    首先说一下这两个是什么？
    我们对于一次web访问，会建立一次链接，在服务端对应的会生成一个session(会话)，因此本次会话的数据会存放在这个session中。会话结束，该session对象就会被销毁。
    而cookie是存在浏览器的用来存放数据，为什么有了session还需要cookie，因为我们会话结束后，session数据就会丢失，因此如果数据需要在多次会话就需要存放在客户端。
    Cookie缺点:不安全，因为存放在客户端可能被盗用。存储大小有限，限4k。客户端可能禁止cookie(禁止则需要将参数通过url传输)。cookie一般用来存储登陆token信息，这样只要登陆一次就不用每次访问都重新登陆

# 多线程

1. 进程和线程区别

   1. 进程是一个运行的程序，是系统资源分配和调度的单位。
   2. 一个进程可以有多个线程，线程是进程中最小的执行单位。
   3. 线程可以共享进程的共享资源和空间地址。
   4. 线程上下文切换时，只需记录当前运行到哪一行代码，进程则需要保存当前CPU环境，和新被调度运行进程的CPU环境设置。

2. 进程通信

3. 怎么通过管道通信

4. 线程状态
   1. runnable 和 running有什么区别
   2. runnable 怎么到 blocked

5. 有哪些实现多线程的方法

6. 线程池有什么参数

7. 线程池的生命周期

   ![线程生命周期](C:\Users\63190\Desktop\pics\线程生命周期.png)

8. synchronized可以用在什么地方，分别有什么作用

9. synchronized和lock的区别

10. 死锁的条件

    1. 资源不能被剥夺，分配的资源在未使用完成前不能前行被剥夺
    2. 互斥条件，一个资源只能被一个线程使用
    3. 请求和等待条件，线程请求其他资源而阻塞时，对持有的资源不放
    4. 循环等待，若干个线程互相阻塞，并等待对方释放持有的资源，从而造成环状。

11. java里final的作用，可以用在哪些地方

12. final的引用对象会变吗

13. 锁有哪些

14. 分布式锁知道吗

15. 加锁有几种方式

16. 悲观锁、乐观锁

17. cas是什么

    

18. cas会自旋吗

19. 那如果会自旋，那一定会成功吗

20. cas存在什么问题

21. aba怎么解决

22. synchronized的jdk优化怎么做的

23. volatile用在哪里

24. volatile什么作用

25. volatile讲一下

26. volatile的内存可见性的实现原理

27. 线程如果更新了一个变量，其他变量的副本会失效，怎么实现的

28. 线程顺序执行

    1. 可以通过 Join() 方法，规定线程必须在 join 线程运行完后才能运行。
    2. 通过逻辑判断，每个线程判断特定的标识才能往下执行。



# 基础

1. 集合类型

   1. list、set、queue、map

2. hashmap的数据结构

   1. 数组+链表

3. 1.7和1.8的hashmap有什么区别

   hashmap 会有一个数组，数组每个下标称为桶，桶用于存储节点。

   jdk 7 时该节点叫 entry，jdk 8 时改为 node，实际上是相同的。

   jdk 7 时每个节点实际上是一个链表节点，每个节点会有一个指针指向下一个相同hash的节点，从而形成链表。jdk1.8之后当链表节点数量大于8时会将链表变成红黑树结构。

   

4. hashmap怎么解决hash冲突

   1. 扩容机制，降低hash冲突
   2. 冲突时，jdk1.7是链表，每个节点实际上会有一个指针指向下一个相同hash的节点，从而形成链表。jdk1.8之后当链表数量大于8时会将链表变成红黑树结构。

   

5. hashmap长度为什么是2的次方

   因为我们要确定桶的位置，所以需要将hashcode的值和桶的大小取模得到key具体落在那个桶。

   而取模的操作实际上在底层中是要换算成位运算的，因此hashmap直接使用位运算提高运算效率。

   当 x为2的次方时，一个数和x-1作与运算等价于取模，所以才要求hashmap的长度为2的次方。如果不是2的次方，默认会改成2的次方。

   

6. hashmap的扩容机制，扩容因子是多少，为什么这样设置

   1. 当hashmap的桶使用个数大于桶的大小*扩容因子时，会进行扩容。因为为了避免hash冲突，所以把数组的大小进行扩容。
   2. 首先会分配一个原来两倍大小的table，然后将旧的table所有键值重新rehash插入到新的table中。

   

7. hashcode怎么计算

   通过将key的hashcode高16位与低16位进行异或运算。

   

8. hashmap怎么找到对象的位置

   1. 首先通过key计算 hashcode，并根据 hashcode 取模 hashmap 大小得到数组具体下标（即桶）。
   2. 如果桶没有元素，则对象不存在，。
   3. 如果桶有元素判断链表或者红黑树的节点key和hashcode是否和查询的对象一直。

   

9. hashmap的树化的条件，为什么这样设置

   1. 当链表节点数量大于8时就会转成红黑树。
   2. 因为链表长度越大，则查询效率越慢，因为链表是顺序查询。因此为了提高查询速率将链表转换成红黑树。

10. hashmap的线程安全问题

    1. 多个线程同时put操作，新插入的头节点可能会被后插入的覆盖。而不是插入两个节点。
    2. 多个线程同时remove操作，移除同一个下标的节点，原本应该移除多次，但可能由于并发，使得移除的实际为同一个节点。
    3. 多个线程触发 resize() 操作，resize() 操作实际上是从链表头开始依次遍历插入到新的数组中，知道节点的next为null就意味着遍历完了，该链表全部挪到了新的数组中。但多线程进行 resize() 时，当一个线程还没对最后一个节点（next为null）插入到新的数组时，此时切换到另一个线程执行 resize()，此时扩容完成后，原本最后一个节点会变成头节点，并且next不为null。此时切换回原线程继续执行，就会导致原来的链表最后一个节点的next不为null，从而导致ABA问题，即B节点指向A节点，但由于上述问题导致B节点的next不为null，而是A，从而又将A节点作为头节点又插入到新的数组中，形成ABA。

    

11. hashmap怎么实现线程安全

    1. 对于hashmap更新的操作，可以同一在外部通过同步的方式访问， 避免多个线程同时修改hashmap。
    2. 使用 JDK 同步包下提供的 ConcurrentHashMap 同步容器。

    

12. hashmap的put操作

    1. 计算出key的hash，落在哪一个桶
    2. 判断数组是否需要初始化
    3. 如果桶的位置为空，那么直接创建节点放到桶中。然后判断是否需要扩容，返回null。
    4. 如果桶的位置不为空
       1. 如果是红黑树则会写入新的节点。
       2. 如果是链表，则会遍历链表，如果以前没有插入过则写入新的节点并判断是否要转成红黑树，反之则返回以前插入过的节点。
    5. 对节点（可能是以前已有的，也可能是新插入的）进行值的修改，然后返回。

    

13. 为什么[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)而不是其他树

14. 1.7和1.8的concurrenthashmap有什么区别

    JDK 1.7 分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock。

    JDK 1.8 的实现不是用了 Segment，Segment 属于重入锁 ReentrantLock。而是使用了内置锁 synchronized，主要是出于以下考虑：

    1. synchronized 的锁粒度更低；
    2. synchronized 优化空间更大；
    3. 在大量数据操作的情况下，ReentrantLock 会开销更多的内存。

    并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。

15. get操作的时候会加锁吗

16. 不加锁怎么保证线程安全

18. concurrenthashmap扩容原理



1. arraylist和 linkedlist 的区别

   arrayList：基于动态数组实现。

   * 查询快，由于通过数组实现，因此可以通过下标直接访问元素。
   * 删除插入慢，因为删除插入会将对应的index后面的元素进行挪动（System.arrayCopy() 进行复制）
   * 扩容慢，因为扩容需要重新分配一个数组（原数组1.5倍），然后进行复制。

   linkedlist：基于双向链表实现。

   * 查询慢，由于链表内存空间不连续，需要顺序遍历每个节点。
   * 插入删除快，由于链表不需要进行将元素进行挪动，只需要对应index前后节点的指针即可。
   * 可以通过linkedlist实现栈、队列、双端队列。
   * 扩容快，因为不需要连续的内存空间。

   

2. 什么时候用arraylist 什么时候用linkedlist

   1. 一般情况都使用 arraylist，因为 arraylist 查询速度快。当然在使用前要预先估计 arraylist 的大小，从而避免扩容带来的耗时。而且也要注意 arraylist 需要连续的内存空间。
   2. 在需要实现栈、队列、双端队列情境下，可以考虑使用 linkedlist。

   

3. hashtable和hashmap的区别

   1. HashTable 是同步的，它使用了 synchronized 来进行同步（所有方法都加锁，意味着同一时间只能有一个线程访问）。它也是线程安全的，多个线程可以共享同一个 HashTable。HashMap 不是同步的，但是可以使用 ConcurrentHashMap，它是 HashTable 的替代，而且比 HashTable 可扩展性更好。

   2. HashMap 可以插入键为 null 的 Entry。

   3. HashMap 的迭代器是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。

   4. 由于 Hashtable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。

      

4. equals和== 区别

   1. ==：如果是基本数据类型，则比较的是值。如果是引用类型，则比较的是引用地址。
   2. equals：比较的是两个对象是否等价。
   
   
   
5. ClassNotFoundException 和 NoClassDefError区别

   ClassNotFoundException 是编译前就会检查出来的错误，找不到指定的 Class，无法编译。

   NoClassDefError 是运行时的错误，编译时该类是存在的，但可能由于以下原因导致运行时类不存在：

   1. 加载该类时发现找不到该类的.class文件或者该类的jar包不存在；
   2. 类的.class文件存在，但是在不同的域中。比如说.class文件在当前的java path下不可用又或者说有多个不同的类加载器重复对该类的.class文件进行了加载，就有可能出现这样的问题。
   3. 大小写问题。如果类名大小写不同，但字母都一样，在编译时只会生成一个全小写的class文件。因此在实际运行时，想加载大写class，但由于只有小写的class文件，则会导致该错误。

   

6. Vector 是否线程安全

   Vector 单个操作的时候确实是线程安全（因为加了 Synchronized），但在复合操作时就不能保证。如 Iterator 遍历时同时修改 Vector，则会抛出 ConcurrentModifyException，因为遍历和修改操作是复合操作。

7. List遍历线程安全

   遍历方式可以分为三种：

   1. for 循环，通过指针遍历
   2. Iterator 迭代器遍历。
   3. foreach 遍历，Java 8提供的Lambda

   前两种在并发情况下（遍历+修改的复合操作），会导致

# JVM

1. 类加载的过程

   1. 装载，通过ClassLoader 对类文件的装载。（使用双亲委派机制）
   2. 链接，主要分为验证（验证文件是否为 class、字节码等信息）、准备（为静态变量分配内存，并进行默认初始化）、解析（将类中的符号引用转换成直接引用，即将引用类的地址替换掉符号引用）
   3. 初始化，对静态变量初始化为用户定义值。

   

2. 双亲委派机制

   1. 类是通过全路径名的区分的，因此同一路径下不能有相同的类。
   2. JVM 有多个ClassLoader，区别在每个 ClassLoader 会加载指定的路径下的类文件，为了避免重复加载同一路径下的类文件，子类 ClassLoader 加载类文件时会先询问父类ClassLoader 是否能加载，如果不能才由自己尝试加载，从而避免了重复加载。

   

3. jvm的内存区域

   1. JVM 内存区域主要分为两个部分：堆和非堆（方法区）
   2. 堆是存储对象实例和数组。方法区是存储类信息、常量池、静态变量、即时编译器生成的数据。
   3. JDK 8 后常量池和静态变量挪到了堆中。

   

4. gc有几种垃圾清理算法

   1. 标记清理法，先标记存活的对象，再清除。

   2. 复制算法，将标记存活的对象复制到另一个内存空间，保证有一个空间是空的，另一个空间的对象整齐存放。

   3. 标记整理法，先标记存活的对象，再将存活的对象压缩到一边，将边界以外的内存清空。

      

5. gc为什么要分代

   1. 通过分代区分不同的对象，并根据每个代的特性选择对应对应的回收算法。堆内存分为新生代和老年代。新创建的对象会在新生代中分配内存，由于新创建的对象80%都会在第一次gc后被回收，因此新生代使用复制回收算法。当对象达到一定的年龄（经历多少次gc都存活）就会被移到老年代存储，老年代gc后，绝大多数对象都还是会存活，因此老年代适合使用标记整理回收算法。

      注意：大对象的创建也会直接存储到老年代。

      

6. G1收集器

   1. g1 收集器使用的是标记整理回收算法。
   2. 对于新生代、老年代不在按照物理隔离，而是将整个堆划分成多个 region 区，每个 region 区都可以成为 eden 区、survivor 区、old 区、h 区。
   3. G1通过优先列表计算各个region里面的垃圾堆积价值（回收获得的空间以及回收所需时间），每次根据允许的收集时间（用户设置），优先回收价值最大的Region（Garbage-First名称的来由）。通过充分利用硬件优势（多CPU、多核）及优先回收的特性尽可能满足用户定义的收集时间（停顿时间），从而使用户线程有更多的时间执行

   

7. G1和CMS的区别

   1. 两者同样是执行过长大致相同，都是初始标记（STW）、并发标记、重新标记（STW）、回收
   2. CMS 作用在老年代、G1是整个内存空间
   3. cms采用的是标记清理、g1整体上采用的是标记整理，具体采用的是复制算法
   4. g1是垃圾优先算法，在满足用户预期的停止时间基础上，尽可能回收垃圾更多的region区。

   

# ORM

1. mybatis了解什么

2. 一级缓存和二级缓存

   1. 一级缓存是会话级别，二级缓存是namespace级别

3. MyBatis 的核心特性

   1、使用连接池对连接进行管理
   2、SQL 和代码分离，集中管理
   3、结果集映射
   4、参数映射和动态SQL
   5、重复SQL 的提取
   6、缓存管理
   7、插件机制



# 数据库

1. **索引的数据结构是什么**

   MySQL中索引有两种数据结构，B+ Tree 和 Hash，而 InnoDB 存储引擎使用的是 B+ Tree。

   

2. **b+树的特点**

   1. B 树有的都有（如节点根据关键字数量变化而进行分裂或合并）
   2. 每个节点的关键字数和路数（子节点）是相同。
   3. 叶子节点才会存储数据。
   4. 叶子节点通过一个指针指向相邻节点，从而形成链表，有利于范围查询
   5. 左闭右开的区间去检索数据。

   

3. **b+树为什么数据都放在叶子节点**

   实际就是 B+ tree 好处。

   1. 由于每访问一层代表一次IO磁盘访问，为了减少层数，减少IO磁盘访问次数，因此将数据都放在叶子节点，非叶子节点存储索引+指针。

      理论上如果索引bint+指针只需14字节，一条数据1kb，我们知道一个节点16k，那么三层就能存储`1170*1170*16=21902400`条数据。

      而且由于访问索引中每一条数据，IO 磁盘访问次数是一致的，一般最多三次就够了，保证了查询速率的稳定。

   2. 叶子节点通过指针指向相邻的节点（有序链表），因此对于范围查询，只需要获取第一个数据，然后顺序遍历链表即可。

   

4. **磁盘IO为什么少，如果没命中数据呢，不也要磁盘io多吗**

   1. 首先使用索引避免了全表扫描。
   2. 由于 b+ tree的特点，检索2000w+数据只需三次 IO 磁盘访问即可。

   

5. **Mysql 数据库有哪些存储引擎**

   最常用的是 MyISAM 和 InnoDB，然后还有 Memory、CVS、Archive。

   

6. **InnoDB 和 MyISAM 的区别**

   1. MyISAM 是5.5版本前默认的存储引擎，InnoDB 是5.5版本后默认的存储引擎
   2. InnoDB 支持事务（因为支持 XA 协议和 SavePoints（嵌套事务）），因此 InnoDB 适合业务数据一致性要求高的场景
   3. InnoDB 支持行级别的锁，MyISAM 支持表级别的锁。因此 InnoDB 适合高并发更新场景（锁粒度小），MyISAM 适合读操作为主的场景。
   4. InnoDB 存储会对每张表生成两个文件（存储结构frm、索引和数据ibd），MyISAM 存储会有三个文件（存储结构frm、索引myi、数据myd），InnoDB 索引和数据是存放在一起，MyISAM 则是分开存储。
   5. MyISAM 索引（主键索引或辅助索引）的叶子节点存的是另一个数据文件中数据对应的磁盘地址，InnDB 主键索引（聚集索引）存的是数据，而辅助索引（非聚集索引）存的是主键值（通过主键值再从主键索引查找数据）

   

7. **innodb的索引怎么实现的**

   InnDB 主键索引（聚集索引）存的是数据，而辅助索引（非聚集索引）存的是主键值（通过主键值再从主键索引查找数据）

   

8. **聚簇索引和非聚簇索引的区别**

   聚集索引（聚簇索引）索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。因此主键索引是聚集索引，非主键索引（辅助索引）为非聚集索引。

   

9. **哪些是非聚簇索引**

   非主键索引（辅助索引）为非聚集索引。

   

10. **什么时候用到唯一索引**

    1. 索引是为了提高查询效率，因此索引列不能频繁更新。
    2. 唯一索引的列不能有重复值，可以有null值。
    3. where 查询中使用到索引字段。

    

11. **联合索引什么时候用到**

    1. 查询判断条件有多个字段，可以对该多个字段建立联合索引，前提是索引值（从而避免建立多个单列索引）

    2. 使用时要符合最左匹配。

       

12. **什么是最左前缀原则**

    1. 使用联合索引要符合最左匹配原则，即（a,b,c）联合索引，实际上等同于 (a)，(a,b)，(a,b,c)三个索引，因此查询时用到的判不能不用第一个字段，不能中断。

    

13. **innodb 中存储2000w个数据，b+ tree 要多少层，计算公式是什么**

    三层，如果索引bint+指针只需14字节，一条数据1kb，我们知道一个节点16k，那么三层就能存储`1170*1170*16=21902400`条数据。

    

14. **事务 acid**

    1. a：atomicity 原子性，事务中的操作要么全部提交成功，要么失败全部回滚。通过 undo log实现，undo log 记录事务中数据修改前的值，一旦失败回滚，就可以通过 undo log 对修改过的数据进行回滚。
    2. c：consisitency 一致性，事务执行前后数据整体上保持一致性，如主键还是唯一的，字段长度要符合，业务上逻辑上是一致的。
    3. i：isolation 隔离性，多个事务同时对同一张表或同一行数据进行操作互不干扰，从而保证数据的一致性。
    4. d：duration 持久性，事务一旦提交，那么事务对应的操作就必定会持久化到磁盘，不会因宕机或重启而导致数据丢失。通过 redo log + double write来保证。redo log 保证数据页的操作一定会执行，double write 保证数据页完整性，保证 redo log恢复时数据页是完整可用的。

    

15. **什么是幻读**

    幻读指其他事务对表插入新的数据，导致事务执行过程中，前后两次查询的数据量不一致。

    

16. **隔离级别有哪些**

    为了解决不同的读一致性问题，数据库划分了四个隔离级别，并且定义每个隔离级别不同程度解决那些读一致性问题，由厂商为具体的隔离级别提供实现：

    1. 未提交读（Read Uncommitted）：事务可以读取其他事务未提交的数据，因此会出现脏读。

    2. 已提交读（read Committed）：事务可以读取其他事务已提交的数据，不可读取其他事务未提交的数据，从而解决了脏读，但会出现不可重复读。

    3. 可重复读（Repeatable Read）：事务执行过程中多次读取同一数据，其数据结果为一致，但没有解决幻读。InnoDB 可以在该隔离级别解决幻读。

    4. 串行化（Serializable）：事务将存放在队列中依次执行，因此不存在并发情况，也就不存在读一致性问题。

       

17. **如何实现可重复读**

    1. InnoDB 通过mvcc 可重复读。
    2. mvcc 通过快照的方式，使得事务内多次读一致，因为读取的是快照的数据。

    

18. **mvcc知道吗，作用**

    1. InnoDB通过 mvcc 实现可重复读事务隔离级别，每个事务开启时，生成一个快照，事务读取数据会从自己的快照读取，从而实现事务内多次读取数据一致。

    

19. **多个线程访问一个数据，怎么保证线程安全**

    实际是事务隔离级别。

    1. 如果多个线程都只是读取数据，那么本身就是线程安全的。但如果涉及读和写则需要一定的机制保证一定的安全。
    2. RC 级别，通过 MVCC 可以解决事务内可重复读，但无法处理事务外的幻读（其他事务插入了数据，导致本事务中读取的数据数量和实际数据数量不一致）
    3. RR 级别，除了 MVCC 解决了事务内可重复读，还提供了间隙锁，使得事务内通过加锁的方式，可以避免其他事务插入数据导致幻读。
    4. Serializable 级别，事务内所有读写操作都加锁，其他事务无法进行修改。

    

20. **除了间隙锁还有什么锁**

    1. 记录锁——锁住单条记录
    2. 临键锁——记录锁+间隙锁

    

21. **事务如果对多个数据库进行操作，怎么实现**

    1. 强一致性，通过协调者（Mycat、Sharding-JDBC等）调用多个数据库的XA接口，控制多个事务的提交或回滚（2pc或者3pc）。
    2. 消息队列，通过失败重试、补偿、预警等机制使得最终一致性，从而避免事务。

    

22. **数据库查询很慢，有什么优化方法**

    1. 首先要定位，慢在哪里。
    2. 大量连接处理。可以考虑客户端使用连接池；服务端进行扩展（如主从模式、或者按照服务拆分数据库）最终目的都是让大量的请求落到不同的数据库节点。
    3. 滚。y。据，不会经常改动的数据，可以考虑加一层缓存层，如Mybatis的缓存（单节点的），更多的是独立缓存服务Redis缓存。
    4. 存储引擎。如以读为主的可以使用 MyISAM，写为主的用 InnoDB。
    5. 语句问题。通过慢SQL查询定位到那些语句慢，然后对语句进行 Explain 分析执行计划。
       1. 语句本身有问题，如有无谓的操作——优化语句本身，全查询——加 limit 分页。
       2. 没有用到索引，建立使用索引。
       3. 数据量大等，一般单表500w建议可以分表，如订单表，可以按照月份分表。
       4. 锁的竞争，
    6. 网络问题。客户端和数据库不在同一个网络，可能会有网络延迟。

    

23. **什么是 Redo log**

    redo log 是一种物理日志，记录的是对物理数据页操作。通过先记录日志，再执行写磁盘，从而保证：

    1. 事务持久化保证：宕机导致内存修改数据没有写入到磁盘中，也能通过启动时加载 redo log 重新对物理数据页操作。

    2. 操作写到一半，宕机，导致数据页不可用，数据失效，也能通过 redo log + 双写缓冲对数据页进行恢复然后再对物理数据页操作

       

24. **什么是 undo log**

    undo log 是事务回滚日志，记录的是逻辑日志（数据在事务之前的状态），redo log 记录前会先将数据状态记录在 undo log，如果事务回滚，则通过该日志直接将数据回滚到事务开启前状态。

    

25. **什么是 binlog**

    事务提交时，会将事务中的更新语句记录在binlog，可以用于数据恢复或者主从复制。
    
    
    
26. **索引失效**

    1. 有or必全有索引;
    2. 复合索引未用左列字段;
    3. like以%开头;
    4. 需要类型转换;
    5. where中索引列有运算;
    6. where中索引列使用了函数;
    7. 如果mysql觉得全表扫描更快时（数据少）;

# Redis

1. **Redis中SDS是什么**

   在 Redis 中通过 SDS 封装字符串，SDS 包含了字符串长度、数组分配大小、SDS类型、字符数组（存储）

   和传统字符数组实现有以下优点：

   1. 不用关注内存溢出问题，提供了扩容机制。
   2. 通过字符串长度属性来判断字符数组结束，而不用判断结束符，从而避免了二进制内容结束符误判问题。
   3. 快速获取字符串长度，不用遍历数组内容。
   4. 通过空间预分配（分配足够的空间）和惰性释放（长度变小不会立刻缩容）机制，避免了频繁扩容/缩容。

   

2. **redis支持哪些数据结构**

   String、Hash、Set、Sort Set、List、bitmap、GEO、Hyperloglogs

   

3. **set的数据结构**

   k/v数据结构，外层是 hashtable（字典），索引到key对应的value（dictEntry），而dictEntry 的redisObject为有两种：

   1. 元素个数少于 512 个通过 inset 存储
   2. 反之则用 Hashtable，key为元素值，val为null

   

4. **string数据结构**

   1. k/v数据结构，外层是 hashtable（字典），索引到key对应的value（dictEntry），而dictEntry 的redisObject为有三种：
      1. int：存储 8 个字节的长整型（long，2^63-1）。
      2. embstr：代表 embstr 格式的 SDS，存储小于44 个字节的字符串。
      3. raw：代表 raw 格式的 SDS，存储大于44 个字节的字符串。

   

5. **redis是单线程的还是多线程的**

   redis 是单线程的。

   

6. **单线程为什么效率这么高**

   1. 基于内存的存储数据，从而避免磁盘 I/O 操作耗时。
   2. 多路复用机制，通过单线程可以同时接收多个请求。
   3. 由于单线程，从而避免线程创建和销毁以及上下文切换和资源竞争问题。
   4. 数据操作简单，没有关联查询等复杂操作。

   

7. **redis怎么保证缓存和数据库数据的一致性**

   强一致性：先删除缓存-》更新数据库-》再删除缓存

   第一次删除是让缓存不可用。

   第二次删除是防止更新数据库前其他客户端访问了数据库导致缓存了旧的值。

   删除操作通过消息队列确保一定成功

   如果可以接受最终一致性：更新数据库 -》 更新缓存（缓存要设置过期时间或者定期更新缓存，从而确保缓存最终一致性）
   
   
   
8. **Redis Cluster 如何批量操作**

   对于 multi key 操作是不能落在同一个节点上处理的，因为每个 key 都有可能映射不同的 slot。为了让多个 key 操作同时落到同一个节点上，可以在 key 后面加上{hash tag}。

# 消息队列

1. mq kafka了解吗
2. 用在什么场景里面



# SpringBoot

1. springboot了解多少
2. spring和springboot区别
3. springboot aop的原理
4. springboot怎么配置依赖



# 设计模式

1. 单例模式有几种实现模式
2. 还了解哪些设计模式
3. 观察者模式讲一下
4. 几种设计模式的应用场景

# 版本工具

1. maven讲一下

# 微服务

1. 公共类的作用
2. 怎么调用总部接口

# 分布式

1. rpc架构了解多少
2. 调用过程是怎样的
3. consumer怎么确定用哪个provider的服务
4. 分布式锁
5. 多机的怎么加锁，实现数据一致
6. 负载均衡怎么做
7. 分布式事务了解吗？

# 算法

1. 求树的高度，最小高度

1. 写一个sql：id, name（重复），取不重复的name，id取最小值
2. 取数组里第k大的数
3. 快排的原理
4. 10亿个数找是否重复
5. 10亿个数找最小的10个，时间复杂度
6. 让你自己实现一个b+树怎么实现
7. 翻转部分
8. 给定单[链表]()，要求返回向右移k位后的新[链表]()，例如：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> NULL。k = 3，则返回：4 -> 5 -> 6 -> 1 -> 2 ->3 -> null。k = 2, 5 6 1 2 3 4。k = 1, 6 1 2 3 4 5。
9. 蛇形遍历[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)





# 项目

1. 主从服

   游戏服每个服都是独立的应用，但由于存在玩法需要多个游戏服进行交互，因此则需要解决数据处理问题。

   需要解决问题：

   1. 数据问题。对于玩家的操作，其数据存储在哪里？如果各自存在本地，那么很容易导致数据不一致问题。因此我们采取了主从服的模式，由主服同一处理写操作，并且主服会将数据同步给其从服，用户查询数据时就可以在本地查询即可。
   2. 主从服选举。通过匹配服根据具体的玩法进行匹配分组，并选举出组内对应的主从服。

   

2. 匹配服

   类 redis 哨兵机制，通过第三方去选举主从服。
   需要解决问题:

   1. 连接问题。所有服启动时都会连接到匹配服，上传服务器相关信息，并通过ping-pong心跳机制。
   2. 选举。根据具体的玩法选出不同的匹配策略进行分组，并选出主从服。（如根据比武大会每个服活跃玩家前十的总战力依次排序，每三个为一组，组内最高的为主服）
   3. 故障转移。当主服出现故障下线时，此时匹配服会从该主服的组中选出新的主服。
   4. 单点问题。虽然匹配服匹配后，每个服会对应缓存其匹配信息，但此时如果匹配服不可用，就会导致新的服无法匹配，以及无法故障转移等问题。因此对匹配服也做了集群，保证匹配服高可用。

   

3. 活动模块

   1. 控制活动的开启与关闭，以及具体活动实现。

   缺点：

   1. 数据存储。活动一般分为本服活动和多服活动，数据选择了存储在一个服中（多服活动为主服开启），该方案是避免了数据同步问题。
   2. 单点问题。由于数据存储在一个服，如果该服不可用，就会影响发奖、活动业务等逻辑。
   3. 开发复杂。需要区分用户是那个服的，如果不是本服，则需要远程通信调用服务。
   4. 不可靠。例如发奖，不能确保从服是否发奖成功。使用补偿机制。

   

   改善点：

   1. 可以将活动模块单独模块化，从而可以实现集群避免服务不可用。
   2. 使用消息中间件，确保发奖流程可靠。

   

4. 排行榜

   1. 由于一开始排行榜只对本服玩家进行，因此设计成本服实现。

      需求：某个副本的通关排行榜

      数据：持久化记录，id为玩家id，记录玩家通过关卡、时间、耗时等信息。

      数据结构：LinkedList（存储排行榜数据）+Map（存储排名）

      操作：

      1. 初始化。加载所有记录到list，并进行排序；将 list 的排名缓存到 map 中（key 玩家id，val 排名）。
      2. 查询。查询玩家排名直接从 map 中获取，查询排行榜信息从 list 获取。
      3. 插入。插入新的记录到 list 中，并进行重排序，更新排名 map。
      4. 更新。根据玩家id找到对应的排名（索引），根据更新list中对应的索引的值，并进行重排序，重排序后更新排名。

   2. 性能问题：由于排行榜不需要实时，而且一个服的玩家有限，因此采取消息队列的方式，将排行榜更新操作放到队列中，

   3. 由于后续出现排行榜对多个服的玩家进行排名，基于本地的实现复杂，因此独立抽出排行榜服务。

      1. 并且使用redis 的 sort set结构实现排行榜

   

5. 合服

   1. 由于游戏服后期人数会减少，为了提高硬件利用率，将多个游戏服的数据合并一起形成新的服。
   2. 实际上通过脚本将数据库数据合并，然后应用启动时对数据进行业务上的合并处理。

   

6. 配置中心

   1. 使用 nacos 实现配置中心，避免了多个实例维护同一份配置，也有利于动态修改配置

   

7. 服务化

   将一些业务单独抽取出来服务化，通过 dubbo + ZooKeeper 实现服务治理。

   好处：

   1. 以前匹配服独立部署，每个游戏服都需要维护地址，且通过 webService 方式调用。使用 dubbo 只需要调用接口即可远程服务调用。
   2. 将排行榜服务化，避免多个服务维护同一份排行榜代码。



7. 线上问题

8. 测试

   1. 在上线前会进行压测

      1. cpu 使用率过高。
         1. 首先查看是什么进程的那个线程使用频繁。可以通过top命令和jstack查看线程。
         2. 用户请求线程：qps过高，可以考虑集群的方式减少单点qps。
         3. 业务线程：如一些轮询的业务（空转），可以考虑改成定时。业务执行时间长，可以考虑异步执行如消息队列。
         4. gc频繁：dump堆内存快照，通过 mat工具分析判断当前内存对象是否合理，如内存泄露。或者是使用其他的垃圾回收器。增加内存大小。
      2. 死锁，通过jstack判断是否出现死锁，从业务逻辑上避免死锁出现。
      3. 测试主体业务流程响应时间，可以考虑缓存或者异步的方式。

      ![JVM 调优指南](C:\Users\63190\Desktop\pics\JVM 调优指南.jpg)



9. 帧同步和状态同步的区别

   游戏中，多个客户端需要看到相同的信息（如技能、动作之类的）。

   帧同步和状态同步的区别在于战斗逻辑写在哪里。

   帧同步的战斗逻辑由客户端处理。客户端的逻辑请求都会发送给服务端，服务端把这一时间段的操作同步给客户端，有客户端根据这一帧发生的事情进行处理，并在客户端展现出来。

   状态同步的战斗逻辑由服务端处理。由于客户端并不能知道游戏所有的信息，因此不能进行战斗逻辑处理，只有服务端才有所有信息，因此需要客户端将操作发送给服务端，服务端处理完后，将结果返回给客户端，客户端展示结果。

10. 

# 自我介绍

面试官，下午好。我叫，今天是参加贵公司游戏后台开发工程师岗位的面试。关于我的工作经历，我在2018年大学时成为三七互娱的实习生，并在接下来两年多的时间在三七互娱担任游戏开发。在三七工作期间参与了三款游戏的开发，其中两款已经上线并取得单月流水过亿的成绩，详细情况可以在我的简历中了解。希望可以通过接下来的面试交流过程中，能让面试官更加了解到我。
