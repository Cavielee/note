# 项目

## 末日沙城

末日沙城是一个单体应用架构，其主要有副本玩法、pvp玩法、活动、匹配等功能。



### 购买礼包

购买礼包其流程一般如下：

#### 防止重复请求

为了解决重复收到多次请求（可能网络原因，可能客户端发了多次）。

* 前端可以按钮置灰
* 后端采用锁的方式

通过锁的方式确保了只会有一个请求进行操作，当购买礼包执行完（成功或者失败）就会释放锁。

**本地锁实现：**

key为用户id+商品id+商品数量，val为线程

通过 putIfAbsent 放到 ConcurrentHashMap（确保只有一个线程获取成功）。

**优良版：Redis 实现**

单体应用中，我们可以控制锁的释放。但在分布式架构中，由于购买礼包的多个流程可能分布在不同的系统中，控制本地锁的释放十分繁杂，因此采用分布式锁的方案，引入 Redis 第三方组件。

通过 Redis 本身单线程的特点，确保了只有一个线程获取到锁。

通过 sexnx 保证只有一个线程获取到锁，ex 保证锁最终一定能被释放成功。

#### 库存减少

库存减少可以看作两个步骤：**判断库存是否够**+**更新数据库值**，此时会遇到两种问题：

1. 多用户同时购买同一个礼包（多线程），可能会导致超卖（因为先判断再去更新）。

   第一种解决方案为：加锁的方式（本地或者 Redis实现），确保只有一个线程执行，效率低。

   第二种解决方案为：乐观锁，update。

   ```sql
   update Goods set count = count - #{购买数量} where id = #{id} and count - #{购买数量} >= 0;
   ```

2. 每次判断库存是否够都需要查询数据库，效率低。

   解决方案：引入缓存。首先判断是否缓存了库存值，如果没有则从数据库获取被更新缓存值。先扣除缓存值，再更新数据库。

   * 可以通过本地使用 Atomic 缓存库存值，先减少缓存值，再乐观锁 update 库存值。
   * 也可以使用 Redis 缓存库存值，redis 可以提供对 key 设置过期时间，从而避免大量缓存商品库存值。首先获取库存缓存值，判断是否够，如果够则使用 incre 方式减少库存，并判断 incre 返回值是否大于等于0，不是则意味着超卖，需要恢复缓存值。（这里实际上可以采用 lua 脚本，将判断和incre操作放在 lua 脚本中，从而确保整个操作原子性，不会出现缓存超卖的情况）

**订单**

库存减少成功后，此时就要生成订单（实际上为插入一条订单数据）。

因为是单体应用，此时可以将库存减少和生成订单放在同一个事务中，如果事务执行失败，则需要回滚库存缓存值。

对于分布式架构中，库存逻辑和订单逻辑可能处于不同系统、不同的数据库，因此我们可以才用基于 2pc 的分布式事务。但一般都是采用最终一致性的柔性事务。

在更新数据库库存时，同时记录交互记录：库存处理状态为已处理，订单处理状态为未处理。

通过线程不断轮询交互记录，将消息发布到 mq 中，发布成功后就可以删除记录，

订单系统去获取 mq 中对应的消息，然后进行订单创建，如果失败则重试，重试一定次数后可以发布失败消息表，可以对失败消息表采取重试或者回退库存或者人工干预。

#### 支付

支付分为两种：外部支付 sdk 或者扣除点券。

扣除点券方式：实际上修改数据库，因此可以将其加入到上面的本地事务中，同样如果失败则需要对回退库存缓存。

外部支付 sdk：这种实际上是调用远程接口，因此一般会等待一定的时间，如果超时没有支付成功，那么需要将库存和订单进行回退，并且回退库存缓存。

上述这些操作我们说要么全部执行成功，要不全部回退。而对于发奖、积分赠送这些操作来说，如果上述操作都执行成功，那必然会执行并且这些操作不会影响主体业务流程，只要求最终一致性。因此采用了消息队列的方式，将订单支付成功的消息发布到对应的本地消息队列，由对应的线程去获取消息进行相关处理。

#### 发奖

获取消息，并进行发奖（入库操作）

#### 积分赠送

获取消息，并进行增加积分。



### 排行榜

积分可能会用于排行榜：

1. 由于一开始排行榜只对本服玩家进行，因此设计成本服实现。

   需求：某个副本的通关排行榜

   数据：持久化记录，id为玩家id，记录玩家通过关卡、时间、耗时等信息。

   数据结构：LinkedList（存储排行榜数据）+Map（存储排名）

   操作：

   1. 初始化。加载所有记录到list，并进行排序；将 list 的排名缓存到 map 中（key 玩家id，val 排名）。
   2. 查询。查询玩家排名直接从 map 中获取，查询排行榜信息从 list 获取。
   3. 插入。插入新的记录到 list 中，并进行重排序，更新排名 map。
   4. 更新。根据玩家id找到对应的排名（索引），根据更新list中对应的索引的值，并进行重排序，重排序后更新排名。

2. 性能问题：由于排行榜不需要实时，而且一个服的玩家有限，因此采取消息队列的方式，将排行榜更新操作放到队列中，

3. 由于后续出现排行榜对多个服的玩家进行排名，基于本地的实现复杂，因此独立抽出排行榜服务。

   1. 并且使用redis 的 sort set结构实现排行榜



### 主从服

1. 游戏服每个服都是独立的应用，但由于存在玩法需要多个游戏服进行交互，因此则需要解决数据处理问题。

   需要解决问题：

   1. 数据问题。对于玩家的操作，其数据存储在哪里？如果各自存在本地，那么很容易导致数据不一致问题。因此我们采取了主从服的模式，由主服同一处理写操作，并且主服会将数据同步给其从服，用户查询数据时就可以在本地查询即可。
   2. 主从服选举。通过匹配服根据具体的玩法进行匹配分组，并选举出组内对应的主从服。

   

2. 匹配服

   类 redis 哨兵机制，通过第三方去选举主从服。
   需要解决问题:

   1. 连接问题。所有服启动时都会连接到匹配服，上传服务器相关信息，并通过ping-pong心跳机制。
   2. 选举。根据具体的玩法选出不同的匹配策略进行分组，并选出主从服。（如根据比武大会每个服活跃玩家前十的总战力依次排序，每三个为一组，组内最高的为主服）
   3. 故障转移。当主服出现故障下线时，此时匹配服会从该主服的组中选出新的主服。
   4. 单点问题。虽然匹配服匹配后，每个服会对应缓存其匹配信息，但此时如果匹配服不可用，就会导致新的服无法匹配，以及无法故障转移等问题。因此对匹配服也做了集群，保证匹配服高可用。

   

3. 活动模块

   1. 控制活动的开启与关闭，以及具体活动实现。

   缺点：

   1. 数据存储。活动一般分为本服活动和多服活动，数据选择了存储在一个服中（多服活动为主服开启），该方案是避免了数据同步问题。
   2. 单点问题。由于数据存储在一个服，如果该服不可用，就会影响发奖、活动业务等逻辑。
   3. 开发复杂。需要区分用户是那个服的，如果不是本服，则需要远程通信调用服务。
   4. 不可靠。例如发奖，不能确保从服是否发奖成功。使用补偿机制。

   

   改善点：

   1. 可以将活动模块单独模块化，从而可以实现集群避免服务不可用。
   2. 使用消息中间件，确保发奖流程可靠。

   

4. 排行榜

   1. 

   

5. 合服

   1. 由于游戏服后期人数会减少，为了提高硬件利用率，将多个游戏服的数据合并一起形成新的服。
   2. 实际上通过脚本将数据库数据合并，然后应用启动时对数据进行业务上的合并处理。

   

6. 配置中心

   1. 使用 nacos 实现配置中心，避免了多个实例维护同一份配置，也有利于动态修改配置

   

7. 服务化

   将一些业务单独抽取出来服务化，通过 dubbo + ZooKeeper 实现服务治理。

   好处：

   1. 以前匹配服独立部署，每个游戏服都需要维护地址，且通过 webService 方式调用。使用 dubbo 只需要调用接口即可远程服务调用。
   2. 将排行榜服务化，避免多个服务维护同一份排行榜代码。



7. 线上问题

8. 测试

   1. 在上线前会进行压测

      1. cpu 使用率过高。
         1. 首先查看是什么进程的那个线程使用频繁。可以通过top命令和jstack查看线程。
         2. 用户请求线程：qps过高，可以考虑集群的方式减少单点qps。
         3. 业务线程：如一些轮询的业务（空转），可以考虑改成定时。业务执行时间长，可以考虑异步执行如消息队列。
         4. gc频繁：dump堆内存快照，通过 mat工具分析判断当前内存对象是否合理，如内存泄露。或者是使用其他的垃圾回收器。增加内存大小。
      2. 死锁，通过jstack判断是否出现死锁，从业务逻辑上避免死锁出现。
      3. 测试主体业务流程响应时间，可以考虑缓存或者异步的方式。

      ![JVM 调优指南](C:\Users\63190\Desktop\pics\JVM 调优指南.jpg)



9. 帧同步和状态同步的区别

   游戏中，多个客户端需要看到相同的信息（如技能、动作之类的）。

   帧同步和状态同步的区别在于战斗逻辑写在哪里。

   帧同步的战斗逻辑由客户端处理。客户端的逻辑请求都会发送给服务端，服务端把这一时间段的操作同步给客户端，有客户端根据这一帧发生的事情进行处理，并在客户端展现出来。

   状态同步的战斗逻辑由服务端处理。由于客户端并不能知道游戏所有的信息，因此不能进行战斗逻辑处理，只有服务端才有所有信息，因此需要客户端将操作发送给服务端，服务端处理完后，将结果返回给客户端，客户端展示结果。

10. 