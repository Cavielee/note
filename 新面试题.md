# 自我介绍

面试官，下午好。我叫李嘉伟，今天是参加休闲游戏岗位的面试。关于我的工作经历，我在2018年大学时成为三七互娱的实习生，并在接下来两年多的时间在三七互娱担任游戏开发。在三七工作期间参与了三款游戏的开发，其中两款已经上线并取得单月流水过亿的成绩，详细情况可以在我的简历中了解。希望可以通过接下来的面试交流过程中，能让面试官更加了解到我。

# 项目

1. 主从服

   游戏服每个服都是独立的应用，但由于存在玩法需要多个游戏服进行交互，因此则需要解决数据处理问题。

   需要解决问题：

   1. 数据问题。对于玩家的操作，其数据存储在哪里？如果各自存在本地，那么很容易导致数据不一致问题。因此我们采取了主从服的模式，由主服同一处理写操作，并且主服会将数据同步给其从服，用户查询数据时就可以在本地查询即可。
   2. 主从服选举。通过匹配服根据具体的玩法进行匹配分组，并选举出组内对应的主从服。

   

2. 匹配服

   类 redis 哨兵机制，通过第三方去选举主从服。
   需要解决问题:

   1. 连接问题。所有服启动时都会连接到匹配服，上传服务器相关信息，并通过ping-pong心跳机制。
   2. 选举。根据具体的玩法选出不同的匹配策略进行分组，并选出主从服。（如根据比武大会每个服活跃玩家前十的总战力依次排序，每三个为一组，组内最高的为主服）
   3. 故障转移。当主服出现故障下线时，此时匹配服会从该主服的组中选出新的主服。
   4. 单点问题。虽然匹配服匹配后，每个服会对应缓存其匹配信息，但此时如果匹配服不可用，就会导致新的服无法匹配，以及无法故障转移等问题。因此对匹配服也做了集群，保证匹配服高可用。

   

3. 活动模块

   1. 控制活动的开启与关闭，以及具体活动实现。

   缺点：

   1. 数据存储。活动一般分为本服活动和多服活动，数据选择了存储在一个服中（多服活动为主服开启），该方案是避免了数据同步问题。
   2. 单点问题。由于数据存储在一个服，如果该服不可用，就会影响发奖、活动业务等逻辑。
   3. 开发复杂。需要区分用户是那个服的，如果不是本服，则需要远程通信调用服务。
   4. 不可靠。例如发奖，不能确保从服是否发奖成功。使用补偿机制。

   

   改善点：

   1. 可以将活动模块单独模块化，从而可以实现集群避免服务不可用。
   2. 使用消息中间件，确保发奖流程可靠。

   

4. 排行榜

   1. 由于一开始排行榜只对本服玩家进行，因此设计成本服实现。

      需求：某个副本的通关排行榜

      数据：持久化记录，id为玩家id，记录玩家通过关卡、时间、耗时等信息。

      数据结构：LinkedList（存储排行榜数据）+Map（存储排名）

      操作：

      1. 初始化。加载所有记录到list，并进行排序；将 list 的排名缓存到 map 中（key 玩家id，val 排名）。
      2. 查询。查询玩家排名直接从 map 中获取，查询排行榜信息从 list 获取。
      3. 插入。插入新的记录到 list 中，并进行重排序，更新排名 map。
      4. 更新。根据玩家id找到对应的排名（索引），根据更新list中对应的索引的值，并进行重排序，重排序后更新排名。

   2. 性能问题：由于排行榜不需要实时，而且一个服的玩家有限，因此采取消息队列的方式，将排行榜更新操作放到队列中，

   3. 由于后续出现排行榜对多个服的玩家进行排名，基于本地的实现复杂，因此独立抽出排行榜服务。

      1. 并且使用redis 的 sort set结构实现排行榜

   

5. 合服

   1. 由于游戏服后期人数会减少，为了提高硬件利用率，将多个游戏服的数据合并一起形成新的服。
   2. 实际上通过脚本将数据库数据合并，然后应用启动时对数据进行业务上的合并处理。

   

6. 配置中心

   1. 使用 nacos 实现配置中心，避免了多个实例维护同一份配置，也有利于动态修改配置

   

7. 服务化

   将一些业务单独抽取出来服务化，通过 dubbo + ZooKeeper 实现服务治理。

   好处：

   1. 以前匹配服独立部署，每个游戏服都需要维护地址，且通过 webService 方式调用。使用 dubbo 只需要调用接口即可远程服务调用。
   2. 将排行榜服务化，避免多个服务维护同一份排行榜代码。



7. 线上问题

8. 测试

   1. 在上线前会进行压测

      1. cpu 使用率过高。
         1. 首先查看是什么进程的那个线程使用频繁。可以通过top命令和jstack查看线程。
         2. 用户请求线程：qps过高，可以考虑集群的方式减少单点qps。
         3. 业务线程：如一些轮询的业务（空转），可以考虑改成定时。业务执行时间长，可以考虑异步执行如消息队列。
         4. gc频繁：dump堆内存快照，通过 mat工具分析判断当前内存对象是否合理，如内存泄露。或者是使用其他的垃圾回收器。增加内存大小。
      2. 死锁，通过jstack判断是否出现死锁，从业务逻辑上避免死锁出现。
      3. 测试主体业务流程响应时间，可以考虑缓存或者异步的方式。

      ![JVM 调优指南](C:\Users\63190\Desktop\pics\JVM 调优指南.jpg)

# 网络

1. OSI七层

   1. 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
   2. 表示层：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。
   3. 会话层：建立及管理会话。

   > 由于表示层和会话层一般交给程序开发去定义具体的实现，因此也可以归结为应用层内容。

   4. 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
   5. 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
   6. 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。
   7. 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

2. cookie和session区别
   首先说一下这两个是什么？
   我们对于一次web访问，会建立一次链接，在服务端对应的会生成一个session(会话)，因此本次会话的数据会存放在这个session中。会话结束，该session对象就会被销毁。
   而cookie是存在浏览器的用来存放数据，为什么有了session还需要cookie，因为我们会话结束后，session数据就会丢失，因此如果数据需要在多次会话就需要存放在客户端。
   Cookie缺点:不安全，因为存放在客户端可能被盗用。存储大小有限，限4k。客户端可能禁止cookie(禁止则需要将参数通过url传输)。cookie一般用来存储登陆token信息，这样只要登陆一次就不用每次访问都重新登陆



# JVM

1. 类加载的过程

   1. 装载，通过ClassLoader 对类文件的装载。（使用双亲委派机制）
   2. 链接，主要分为验证（验证文件是否为 class、字节码等信息）、准备（为静态变量分配内存，并进行默认初始化）、解析（将类中的符号引用转换成直接引用，即将引用类的地址替换掉符号引用）
   3. 初始化，对静态变量初始化为用户定义值。

   

2. 双亲委派机制

   1. 类是通过全路径名的区分的，因此同一路径下不能有相同的类。
   2. JVM 有多个ClassLoader，区别在每个 ClassLoader 会加载指定的路径下的类文件，为了避免重复加载同一路径下的类文件，子类 ClassLoader 加载类文件时会先询问父类ClassLoader 是否能加载，如果不能才由自己尝试加载，从而避免了重复加载。

   

3. jvm的内存区域

   1. JVM 内存区域主要分为两个部分：堆和非堆（方法区）
   2. 堆是存储对象实例和数组。方法区是存储类信息、常量池、静态变量、即时编译器生成的数据。
   3. JDK 8 后常量池和静态变量挪到了堆中。

   

4. gc有几种垃圾清理算法

   1. 标记清理法，先标记存活的对象，再清除。

   2. 复制算法，将标记存活的对象复制到另一个内存空间，保证有一个空间是空的，另一个空间的对象整齐存放。

   3. 标记整理法，先标记存活的对象，再将存活的对象压缩到一边，将边界以外的内存清空。

      

5. gc为什么要分代

   1. 通过分代区分不同的对象，并根据每个代的特性选择对应对应的回收算法。堆内存分为新生代和老年代。新创建的对象会在新生代中分配内存，由于新创建的对象80%都会在第一次gc后被回收，因此新生代使用复制回收算法。当对象达到一定的年龄（经历多少次gc都存活）就会被移到老年代存储，老年代gc后，绝大多数对象都还是会存活，因此老年代适合使用标记整理回收算法。

      注意：大对象的创建也会直接存储到老年代。

      

6. G1收集器

   1. g1 收集器使用的是标记整理回收算法。
   2. 对于新生代、老年代不在按照物理隔离，而是将整个堆划分成多个 region 区，每个 region 区都可以成为 eden 区、survivor 区、old 区、h 区。
   3. G1通过优先列表计算各个region里面的垃圾堆积价值（回收获得的空间以及回收所需时间），每次根据允许的收集时间（用户设置），优先回收价值最大的Region（Garbage-First名称的来由）。通过充分利用硬件优势（多CPU、多核）及优先回收的特性尽可能满足用户定义的收集时间（停顿时间），从而使用户线程有更多的时间执行

   

7. G1和CMS的区别

   1. 两者同样是执行过长大致相同，都是初始标记（STW）、并发标记、重新标记（STW）、回收
   2. CMS 作用在老年代、G1是整个内存空间
   3. cms采用的是标记清理、g1整体上采用的是标记整理，具体采用的是复制算法
   4. g1是垃圾优先算法，在满足用户预期的停止时间基础上，尽可能回收垃圾更多的region区。




# ORM

1. mybatis了解什么

2. 一级缓存和二级缓存

   1. 一级缓存是会话级别，二级缓存是namespace级别

3. MyBatis 的核心特性

   1、使用连接池对连接进行管理
   2、SQL 和代码分离，集中管理
   3、结果集映射
   4、参数映射和动态SQL
   5、重复SQL 的提取
   6、缓存管理
   7、插件机制



# 数据库

1. **索引的数据结构是什么**

   MySQL中索引有两种数据结构，B+ Tree 和 Hash，而 InnoDB 存储引擎使用的是 B+ Tree。

   

2. **b+树的特点**

   1. B 树有的都有（如节点根据关键字数量变化而进行分裂或合并）
   2. 每个节点的关键字数和路数（子节点）是相同。
   3. 叶子节点才会存储数据。
   4. 叶子节点通过一个指针指向相邻节点，从而形成链表，有利于范围查询
   5. 左闭右开的区间去检索数据。

   

3. **b+树为什么数据都放在叶子节点**

   实际就是 B+ tree 好处。

   1. 由于每访问一层代表一次IO磁盘访问，为了减少层数，减少IO磁盘访问次数，因此将数据都放在叶子节点，非叶子节点存储索引+指针。

      理论上如果索引bint+指针只需14字节，一条数据1kb，我们知道一个节点16k，那么三层就能存储`1170*1170*16=21902400`条数据。

      而且由于访问索引中每一条数据，IO 磁盘访问次数是一致的，一般最多三次就够了，保证了查询速率的稳定。

   2. 叶子节点通过指针指向相邻的节点（有序链表），因此对于范围查询，只需要获取第一个数据，然后顺序遍历链表即可。

   

4. **磁盘IO为什么少，如果没命中数据呢，不也要磁盘io多吗**

   1. 首先使用索引避免了全表扫描。
   2. 由于 b+ tree的特点，检索2000w+数据只需三次 IO 磁盘访问即可。

   

5. **Mysql 数据库有哪些存储引擎**

   最常用的是 MyISAM 和 InnoDB，然后还有 Memory、CVS、Archive。

   

6. **InnoDB 和 MyISAM 的区别**

   1. MyISAM 是5.5版本前默认的存储引擎，InnoDB 是5.5版本后默认的存储引擎
   2. InnoDB 支持事务（因为支持 XA 协议和 SavePoints（嵌套事务）），因此 InnoDB 适合业务数据一致性要求高的场景
   3. InnoDB 支持行级别的锁，MyISAM 支持表级别的锁。因此 InnoDB 适合高并发更新场景（锁粒度小），MyISAM 适合读操作为主的场景。
   4. InnoDB 存储会对每张表生成两个文件（存储结构frm、索引和数据ibd），MyISAM 存储会有三个文件（存储结构frm、索引myi、数据myd），InnoDB 索引和数据是存放在一起，MyISAM 则是分开存储。
   5. MyISAM 索引（主键索引或辅助索引）的叶子节点存的是另一个数据文件中数据对应的磁盘地址，InnDB 主键索引（聚集索引）存的是数据，而辅助索引（非聚集索引）存的是主键值（通过主键值再从主键索引查找数据）

   

7. **innodb的索引怎么实现的**

   InnDB 主键索引（聚集索引）存的是数据，而辅助索引（非聚集索引）存的是主键值（通过主键值再从主键索引查找数据）

   

8. **聚簇索引和非聚簇索引的区别**

   聚集索引（聚簇索引）索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。因此主键索引是聚集索引，非主键索引（辅助索引）为非聚集索引。

   

9. **哪些是非聚簇索引**

   非主键索引（辅助索引）为非聚集索引。

   

10. **什么时候用到唯一索引**

    1. 索引是为了提高查询效率，因此索引列不能频繁更新。
    2. 唯一索引的列不能有重复值，可以有null值。
    3. where 查询中使用到索引字段。

    

11. **联合索引什么时候用到**

    1. 查询判断条件有多个字段，可以对该多个字段建立联合索引，前提是索引值（从而避免建立多个单列索引）

    2. 使用时要符合最左匹配。

       

12. **什么是最左前缀原则**

    1. 使用联合索引要符合最左匹配原则，即（a,b,c）联合索引，实际上等同于 (a)，(a,b)，(a,b,c)三个索引，因此查询时用到的判不能不用第一个字段，不能中断。

    

13. **innodb 中存储2000w个数据，b+ tree 要多少层，计算公式是什么**

    三层，如果索引bint+指针只需14字节，一条数据1kb，我们知道一个节点16k，那么三层就能存储`1170*1170*16=21902400`条数据。

    

14. **事务 acid**

    1. a：atomicity 原子性，事务中的操作要么全部提交成功，要么失败全部回滚。通过 undo log实现，undo log 记录事务中数据修改前的值，一旦失败回滚，就可以通过 undo log 对修改过的数据进行回滚。
    2. c：consisitency 一致性，事务执行前后数据整体上保持一致性，如主键还是唯一的，字段长度要符合，业务上逻辑上是一致的。
    3. i：isolation 隔离性，多个事务同时对同一张表或同一行数据进行操作互不干扰，从而保证数据的一致性。
    4. d：duration 持久性，事务一旦提交，那么事务对应的操作就必定会持久化到磁盘，不会因宕机或重启而导致数据丢失。通过 redo log + double write来保证。redo log 保证数据页的操作一定会执行，double write 保证数据页完整性，保证 redo log恢复时数据页是完整可用的。

    

15. **什么是幻读**

    幻读指其他事务对表插入新的数据，导致事务执行过程中，前后两次查询的数据量不一致。

    

16. **隔离级别有哪些**

    为了解决不同的读一致性问题，数据库划分了四个隔离级别，并且定义每个隔离级别不同程度解决那些读一致性问题，由厂商为具体的隔离级别提供实现：

    1. 未提交读（Read Uncommitted）：事务可以读取其他事务未提交的数据，因此会出现脏读。

    2. 已提交读（read Committed）：事务可以读取其他事务已提交的数据，不可读取其他事务未提交的数据，从而解决了脏读，但会出现不可重复读。

    3. 可重复读（Repeatable Read）：事务执行过程中多次读取同一数据，其数据结果为一致，但没有解决幻读。InnoDB 可以在该隔离级别解决幻读。

    4. 串行化（Serializable）：事务将存放在队列中依次执行，因此不存在并发情况，也就不存在读一致性问题。

       

17. **如何实现可重复读**

    1. InnoDB 通过mvcc 可重复读。
    2. mvcc 通过快照的方式，使得事务内多次读一致，因为读取的是快照的数据。

    

18. **mvcc知道吗，作用**

    1. InnoDB通过 mvcc 实现可重复读事务隔离级别，每个事务开启时，生成一个快照，事务读取数据会从自己的快照读取，从而实现事务内多次读取数据一致。

    

19. **多个线程访问一个数据，怎么保证线程安全**

    实际是事务隔离级别。

    1. 如果多个线程都只是读取数据，那么本身就是线程安全的。但如果涉及读和写则需要一定的机制保证一定的安全。
    2. RC 级别，通过 MVCC 可以解决事务内可重复读，但无法处理事务外的幻读（其他事务插入了数据，导致本事务中读取的数据数量和实际数据数量不一致）
    3. RR 级别，除了 MVCC 解决了事务内可重复读，还提供了间隙锁，使得事务内通过加锁的方式，可以避免其他事务插入数据导致幻读。
    4. Serializable 级别，事务内所有读写操作都加锁，其他事务无法进行修改。

    

20. **除了间隙锁还有什么锁**

    1. 记录锁——锁住单条记录
    2. 临键锁——记录锁+间隙锁

    

21. **事务如果对多个数据库进行操作，怎么实现**

    1. 强一致性，通过协调者（Mycat、Sharding-JDBC等）调用多个数据库的XA接口，控制多个事务的提交或回滚（2pc或者3pc）。
    2. 消息队列，通过失败重试、补偿、预警等机制使得最终一致性，从而避免事务。

    

22. **数据库查询很慢，有什么优化方法**

    1. 首先要定位，慢在哪里。
    2. 大量连接处理。可以考虑客户端使用连接池；服务端进行扩展（如主从模式、或者按照服务拆分数据库）最终目的都是让大量的请求落到不同的数据库节点。
    3. 滚。y。据，不会经常改动的数据，可以考虑加一层缓存层，如Mybatis的缓存（单节点的），更多的是独立缓存服务Redis缓存。
    4. 存储引擎。如以读为主的可以使用 MyISAM，写为主的用 InnoDB。
    5. 语句问题。通过慢SQL查询定位到那些语句慢，然后对语句进行 Explain 分析执行计划。
       1. 语句本身有问题，如有无谓的操作——优化语句本身，全查询——加 limit 分页。
       2. 没有用到索引，建立使用索引。
       3. 数据量大等，一般单表500w建议可以分表，如订单表，可以按照月份分表。
       4. 锁的竞争，
    6. 网络问题。客户端和数据库不在同一个网络，可能会有网络延迟。

    

23. **什么是 Redo log**

    redo log 是一种物理日志，记录的是对物理数据页操作。通过先记录日志，再执行写磁盘，从而保证：

    1. 事务持久化保证：宕机导致内存修改数据没有写入到磁盘中，也能通过启动时加载 redo log 重新对物理数据页操作。

    2. 操作写到一半，宕机，导致数据页不可用，数据失效，也能通过 redo log + 双写缓冲对数据页进行恢复然后再对物理数据页操作

       

24. **什么是 undo log**

    undo log 是事务回滚日志，记录的是逻辑日志（数据在事务之前的状态），redo log 记录前会先将数据状态记录在 undo log，如果事务回滚，则通过该日志直接将数据回滚到事务开启前状态。

    

25. **什么是 binlog**

    事务提交时，会将事务中的更新语句记录在binlog，可以用于数据恢复或者主从复制。

    

26. **索引失效**

    1. 有or必全有索引;
    2. 复合索引未用左列字段;
    3. like以%开头;
    4. 需要类型转换;
    5. where中索引列有运算;
    6. where中索引列使用了函数;
    7. 如果mysql觉得全表扫描更快时（数据少）;

# Redis

1. **Redis中SDS是什么**

   在 Redis 中通过 SDS 封装字符串，SDS 包含了字符串长度、数组分配大小、SDS类型、字符数组（存储）

   和传统字符数组实现有以下优点：

   1. 不用关注内存溢出问题，提供了扩容机制。
   2. 通过字符串长度属性来判断字符数组结束，而不用判断结束符，从而避免了二进制内容结束符误判问题。
   3. 快速获取字符串长度，不用遍历数组内容。
   4. 通过空间预分配（分配足够的空间）和惰性释放（长度变小不会立刻缩容）机制，避免了频繁扩容/缩容。

   

2. **redis支持哪些数据结构**

   String、Hash、Set、Sort Set、List、bitmap、GEO、Hyperloglogs

   

3. **set的数据结构**

   k/v数据结构，外层是 hashtable（字典），索引到key对应的value（dictEntry），而dictEntry 的redisObject为有两种：

   1. 元素个数少于 512 个通过 inset 存储
   2. 反之则用 Hashtable，key为元素值，val为null

   

4. **string数据结构**

   1. k/v数据结构，外层是 hashtable（字典），索引到key对应的value（dictEntry），而dictEntry 的redisObject为有三种：
      1. int：存储 8 个字节的长整型（long，2^63-1）。
      2. embstr：代表 embstr 格式的 SDS，存储小于44 个字节的字符串。
      3. raw：代表 raw 格式的 SDS，存储大于44 个字节的字符串。

   

5. **redis是单线程的还是多线程的**

   redis 是单线程的。

   

6. **单线程为什么效率这么高**

   1. 基于内存的存储数据，从而避免磁盘 I/O 操作耗时。
   2. 多路复用机制，通过单线程可以同时接收多个请求。
   3. 由于单线程，从而避免线程创建和销毁以及上下文切换和资源竞争问题。
   4. 数据操作简单，没有关联查询等复杂操作。

   

7. **redis怎么保证缓存和数据库数据的一致性**

   强一致性：先删除缓存-》更新数据库-》再删除缓存

   第一次删除是让缓存不可用。

   第二次删除是防止更新数据库前其他客户端访问了数据库导致缓存了旧的值。

   删除操作通过消息队列确保一定成功

   如果可以接受最终一致性：更新数据库 -》 更新缓存（缓存要设置过期时间或者定期更新缓存，从而确保缓存最终一致性）

# Spring

1. IOC 容器初始化可以总结为以下步骤：

   1. 初始化的入口在容器实现中的 refresh() 调用来完成。
   2. 使用 ResourceLoader 对 Bean 配置进行定位（容器本身就继承了 ResourceLoader 的默认实现DefaultResourceLoader），并加载配置资源 Resource。
   3. 使用 BeanDefinitionReader （如 xml 使用 XmlBeanDefinitionReader，注解使用 AnnotatedBeanDefinitionReader）将上一步加载的 Resource 解析成 BeanDefinition（Spring Bean 的定义） 并注册到 IOC 容器中（容器持有 BeanFactory 的默认实现类 DefaultListableBeanFactory），实际上就是使用一个 HashMap 去存储 BeanName 和对应的 BeanDefinition。
   4. 容器本身就是一个 BeanFactory，其定义了对 Bean 的获取等操作接口，最终调用的是容器本身持有的 BeanFactory 的子类 DefaultListableBeanFactory 的方法实现。




2. 实例化和注入
   1. 对于不是懒加载且 Singleton 模式的 Bean 会在初始化时实例化，而如果是懒加载（默认）的 Bean 则在 getBean() 时才会实例化 Bean。
   2. getBean() 作为实例化入口，首先会在 IOC 容器缓存中获取，没有则往父级容器缓存中尝试获取。
   3. 如果缓存都没有则实例化 Bean，实例化前先对依赖的（dependsOn）Bean 实例化，即对其调用 getBean()方法。若有循环依赖则会报错。
   4. 根据创建模式，如 singleton、prototype等创建其实例，实际调用AbstractAutowireCapableBeanFactory.createBeanInstance() 实例化对象。
   5. 根据不同的初始化策略实例化 Bean 对象。
   6. 使用 JDK 的反射方法或者 CGLib方式实例化对象。
   7. 创建后的实例对象（Singleton 模式）先将引用缓存到 IOC 容器中。
   8. 根据属性类型进行值转换。
   9. 根据属性类型进行值注入。



3. AOP

   1. 根据 AOP 配置判断是否有 Advisor 符合 Bean，如果有就选择对应的策略（JDK 动态代理/CGLib 动态代理）创建代理对象。
   2. 调用代理对象方法时，获得该方法的拦截器链，通过拦截器链触发通知执行。

4. Spring MVC

   1. Spring MVC 自带 Web 容器，程序员开发时不需要单独将工程部署到 Web 容器上，直接运行 Spring MVC 项目即可运行 Web 服务。
   2. Spring MVC 对 Web 架构进行分层模型，主要分为三层：Controller 层（用于定义 Web 服务接口，即常见的一个 url 对应一个接口方法），Service 层（具体的业务逻辑），DAO 层（操作数据库）。
   3. Spring MVC 提供核心类 DispatcherServlet，其实现 HttpServlet。开发时只需在配置该 DispatcherServlet 的具体实现类即可。客户端访问时，会由底层的 Web 容器封装对应的 Request/Response 传到 DispatcherServlet，并由 DispatcherServlet 作为调度器调度一系列组件进行处理。
   4. DispatcherServlet 首先调度 HandlerMapping，找到请求 url 对应的执行链（handler 和 interceptor）。
   5. DispatcherServlet 将第四步获得的执行链交给 HandlerAdapter 进行处理，HandlerAdapter 将请求数据适配转换成方法所需参数，并调用方法。
   6. DispatcherServlet 将方法处理完后会返回视图数据交给对应的 ViewResolver  解析成 View，最终通过 View 进行视图数据渲染返回给客户端。

5. jdk 和 cglib动态代理

   aop实现原理，以及jdk动态代理会遇到的问题？
   在spring中会有两种方式实现动态代理。
   分别是jdk提供的和cglib，spring默认使用jdk实现，但是jdk是基于接口实现，动态代理的方法需要在接口中定义。因此会存在问题:如果代理类没有接口实现，就不能进行动态代理。
   那cglib就没有什么问题了吗？
   而cglib是基于继承的形式，动态生成代理类的子类字节码文件。因此存在问题:如果类是final就不能使用cglib
   因此我们一般推荐面向接口编程



6. PrepareStatement 好处

   1. 批量操作时可以利用 PrepareStatement 的预编译特性，从而避免多次编译，导致执行效率慢。
   2. 参数占位符，提供占位符的机制，避免编写多次重复语句。
   3. 防止 SQL 注入。因为参数是作为 String 解析，而不会经历编译阶段。

7. jdbc

   使用传统的 JDBC 编写数据库操作时需要以下步骤：

   1. 加载驱动程序
   2. 获得数据库连接
   3. 操作数据库，实现增删改查
   4. 获取结果集并遍历结果
   5. 关闭ResultSet、Statement、Connection资源

   当然使用数据库连接池可以节省为：

   1. 从 DataSource 获取连接
   2. 操作数据库，实现增删改查
   3. 获取结果集并遍历结果



Vector 是否线程安全

线程安全的list

classNotFoundException 和 noClassDefException区别

Netty 零拷贝作用