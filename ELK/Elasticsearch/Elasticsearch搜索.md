# 空搜索

返回集群中所有索引下的所有文档

```sh
GET /_search
```

返回结果大致如下：

```json
{
   "hits" : {
      "total" :       14,
      "hits" : [
        {
          "_index":   "us",
          "_type":    "tweet",
          "_id":      "7",
          "_score":   1,
          "_source": {
             "date":    "2014-09-17",
             "name":    "John Smith",
             "tweet":   "The Query DSL is really powerful and flexible",
             "user_id": 2
          }
       },
        ... 9 RESULTS REMOVED ...
      ],
      "max_score" :   1
   },
   "took" :           4,
   "_shards" : {
      "failed" :      0,
      "successful" :  10,
      "total" :       10
   },
   "timed_out" :      false
}
```

## hits

返回结果中最重要的部分是 `hits` ，它 包含 `total` 字段来表示匹配到的文档总数，并且一个 `hits` 数组包含所查询结果的前十个文档。

在 `hits` 数组中每个结果包含文档的 `_index` 、 `_type` 、 `_id` ，加上 `_source` 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。

每个结果还有一个 `_score` ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 `_score` 降序排列的。

`max_score` 值是与查询所匹配文档的 `_score` 的最大值。



## took

`took` 值告诉我们执行整个搜索请求耗费了多少毫秒。



## shards

`_shards` 部分告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。



## timeout

`timed_out` 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 `timeout` 为 10 或者 10ms（10毫秒），或者 1s（1秒）：

```sh
GET /_search?timeout=10ms
```

在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。



> 应当注意的是 `timeout` 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。
>
> 使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。



# 多索引，多类型

如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：

* `/_search`：在所有的索引中搜索所有的类型

* `/gb/_search`：在 `gb` 索引中搜索所有的类型

* `/gb,us/_search`：在 `gb` 和 `us` 索引中搜索所有的文档

* `/g*,u*/_search`：在任何以 `g` 或者 `u` 开头的索引中搜索所有的类型

* `/gb/user/_search`：在 `gb` 索引中搜索 `user` 类型

* `/gb,us/user,tweet/_search`：在 `gb` 和 `us` 索引中搜索 `user` 和 `tweet` 类型

* `/_all/user,tweet/_search`：在所有的索引中搜索 `user` 和 `tweet` 类型



当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的--只是会涉及到更多的分片。

> 搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。



# 分页

由于搜索的结果 `hits` 数组中最多只能显示 10 个文档。Elasticsearch 可以通过 `from` 和 `size` 参数来查看指定范围的文档：

- `size`

  显示应该返回的结果数量，默认是 `10`

- `from`

  显示应该跳过的初始结果数量，默认是 `0`

## **深度分页**

考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。

假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 *协调节点* ，协调节点对 50 个结果排序得到全部结果的前 10 个。

现在假设我们请求第 1000 页--结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。

可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。



# 轻量搜索

“轻量的” 查询字符串版本，要求在查询字符串中传递所有的参数。

例如，查询在 `tweet` 类型中 `tweet` 字段包含 `elasticsearch` 单词的所有文档：

```sh
GET /_all/tweet/_search?q=tweet:elasticsearch
```

 `name` 字段中包含 `john` 并且在 `tweet` 字段中包含 `mary` 的文档：

```sh
+name:john +tweet:mary
```

但是查询字符串参数所需要的 *百分比编码* （译者注：URL编码）实际上更加难懂：

```sh
GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary
```

`+` 前缀表示必须与查询条件匹配。类似地， `-` 前缀表示一定不与查询条件匹配。没有 `+` 或者 `-` 的所有其他条件都是可选的——匹配的越多，文档就越相关。



## _all

当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 `_all` 字段进行索引。

除非指定查询的字段，否则查询字符串就使用 `_all` 字段进行搜索。



缺点：

* 一些查询字符串中很小的语法错误，像 `-` ， `:` ， `/` 或者 `"` 不匹配等，将会返回错误而不是搜索结果。
* 查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。