# RESTFul

REST（Representational State Transfer），是一种 API 设计规范，用于 Web 数据接口的设计。

通过 REST 规范实现系统的高性能、可伸缩、通用性、简单性、可修改性和可扩展等特性。



## URL 设计

在 WEB 服务中，客户端可以通过访问指定的 url 从而访问服务。

一般 WEB 服务都是对服务端资源进行 CRUD 的操作，如对图书馆系统的图书进行增删改查：

* 查找：http://www.xxx.com/library/get-book?id=1
* 修改：http://www.xxx.com/library/update-book?id=1...
* 添加：http://www.xxx.com/library/add-book?id=1...
* 删除：http://www.xxx.com/library/delete-book?id=1

可以看出上面的设计风格，无法从 url 中直接定位出客户端想要操作的是服务端具体哪个资源，而需要从参数中定位具体操作的资源。

而 REST 中则是通过 url 的方式准确定位出操作的资源：

* 指定 id 的 book：http://www.xxx.com/library/books/1
* 所有 book：http://www.xxx.com/library/books

* 指定分类的所有book：http://www.xxx.com/library/books/category/internet

REST 风格中，可以很好的通过 url 定位到要操作的资源。

> 由于 REST 是通过 url 定位资源，因此 url 一定是名词形式，不能带有动词。



### 复数问题

由于资源在实际中可能是单数也可能是集合（复数），因此会有以下规范：

对于复数的资源应该使用s修饰名词：

http://www.xxx.com/books：表示定位所有图书资源

但如果要操作某个图书，为了统一 url，应当为 http://www.xxx.com/books/1，而不是  http://www.xxx.com/book/1



### 避免多层级

当操作的资源是集合时，如：

* 获取某个作者的某一类文章：

```
/authors/12/categories/2
```

* 获取所有已发布的文章：

```
/articles/published
```

上述的 url 中，为了筛选集合中的资源，增加了多层级。缺点如下：

* 阅读性不好，用户很难第一时间知道每个路径代表什么意思。
* 增加新的筛选条件，则需要新增 url 来表示。

如果要筛选集合中的资源，应尽量的采用参数的形式从代码上进行过滤，而不是通过层级 url 接口的方式进行筛选。修改后如下：

```
/authors/12?categories=2
/articles?published=true
```



### 其他规范

* URI结尾不应包含（/）
* 正斜杠分隔符（/）必须用来指示层级关系
* 应使用连字符（ - ）来提高URI的可读性
* 不得在URI中使用下划线（_）
* URI路径中全都使用小写字母



## Method 设计

URL 的设计可以定位到具体操作的资源，那么该服务接口具体需要对资源进行什么操作，则需要通过 HTTP 的 Method 表达对资源进行什么操作。

HTTP 提供 4 种 Method：

* Get：用于获取资源。
* Put：用于更新资源。
* Post：用于创建资源。
* Delete：用于删除资源。

### 幂等性

幂等性指的是多次调用是否会造成多次影响。

如上述的 Get、Put、Delete 方式对资源进行操作时应当保证幂等性：

1. 在资源没有被修改的前提下，多次获取资源应当返回相同的资源结果。
2. 多次 Put 修改资源，如果修改内容相同，则应该保证修改操作覆盖不会造成实际影响。
3. 多次 Delete 删除资源，资源只会被删除一次，后面删除操作不会删除成功。

Post 操作不是幂等，因为多次创建资源可能会导致创建多个资源。



## 状态码

客户端的每一次请求，服务器都必须给出回应，回应用于告诉客户端请求的执行结果。

客户端和服务端可以自定义一套响应消息，并封装放在响应报文 body 中。

而在 REST 中，对应响应消息使用的是 HTTP 的状态码来表示请求执行的结果。

根据状态码可以知道资源的操作结果，HTTP 状态码大致分成五个类别：

* 1xx：相关信息
* 2xx：操作成功
* 3xx：重定向
* 4xx：客户端错误
* 5xx：服务器错误

这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。

API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。



### 2XX状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 表示操作成功。响应内容取决于调用的 Http Method。             |
| 201    | 表示资源创建成功（一般为 Post 方法返回的结果）。响应内容为空或者为新创建资源的 URI，响应的 Location 头指向新的资源的 URI。 |
| 202    | 表示请求已被接受，但还未进行处理，响应结果中的 URI 提供执行状态更新。通常用于异步操作，客户端需要不断轮询获取执行状态。 |
| 204    | 表示资源已经不存在（一般为 Delete 方法返回的结果）。         |



### 3xx 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 301    | 永久移除。表示资源不在定位于该 URI，新的 URI 会在响应头的 Location 返回。只有 GET/HEAD 请求应当重定向到新的资源位置。客户端应该对该资源的 URI 更新为新的 URI。 |
| 302    | 临时重定向。表示资源 URI 应定位到新的 URI，新的 URI 会在响应头的 Location 返回。只有 GET/HEAD 请求应当重定向到新的资源位置。客户端不需要将该资源的 URI 更新为新的 URI。一般不推荐使用。 |
| 303    | 表示参考另一个 URL。和 302 含义一样，但区别在于用于 Post、Put 和 Delete 请求。客户端根据收到的响应作出下一步操作的决定。 |
| 307    | 和 302 作用一样。                                            |



### 4xx 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 400    | 服务器不理解客户端的请求，未做任何处理。                     |
| 401    | 用户未提供身份验证凭据，或者没有通过身份验证。               |
| 403    | 用户通过了身份验证，但是不具有访问资源所需的权限。           |
| 404    | 所请求的资源不存在，或不可用。                               |
| 405    | 用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。 |
| 410    | 所请求的资源已从这个地址转移，不再可用。                     |
| 415    | 客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。 |
| 422    | 客户端上传的附件无法处理，导致请求失败。                     |
| 429    | 客户端的请求次数超过限额。                                   |



### 5xx 状态码

5xx状态码表示服务端错误。

| 状态码 | 描述                                       |
| ------ | ------------------------------------------ |
| 500    | 客户端请求有效，服务器处理时发生了意外。   |
| 501    | 服务未实现。                               |
| 503    | 服务器无法处理请求，一般用于网站维护状态。 |



## 响应内容

客户端可以通过 Aceept 表示客户端可接受响应内容的媒体类型。如：

```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
```

上述表示：

第一优先顺序：text/html -> application/xhtml+xml -> application/xml

第二优先顺序：image/webp -> image/apng

服务端则可以通过设置响应头  Content-Type 表示返回的响应内容的媒体类型。

> 一般建议不要使用纯文本类型，普遍使用 application/json。



### Spring MessageConverter

Spring 对于响应内容提供多种 HttpMessageConverter 的具体实现类，如 JSON、XML、TEXT 等，根据请求的 Accepts 支持的媒体类型找到响应返回内容对应的 HttpMessageConverter  进行写入。

如客户端支持 `application/json，*/*`，服务端响应的内容为 Object，JsonbHttpMessageConverter 刚好支持响应内容转换，则会将响应对象通过 JsonbHttpMessageConverter 转换成 Json 内容响应给客户端。
