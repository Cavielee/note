MySQL 作为开源的数据库，其有许多分支如：

* CentOS 7 自带的 MariaDB。（默认使用Maria 存储引擎，该引擎是MyISAM 存储引擎的升级版本）
* Percona Server。（默认使用XtraDB 引擎，它基于InnoDB 存储引擎）

# 工作流程

一条 SQL 语句的执行流程如下：

![Mysql执行流程](https://raw.githubusercontent.com/Cavielee/notePics/main/Mysql执行流程.jpg)



## 通信

客户端要和数据库交互首先要建立连接。如何建立连接？就需要通过通信协议进行连接交互。

> 对于我们开发的系统跟第三方对接，需要指定两件事：通信协议和消息格式
>
> 通信协议：常见的有HTTP、WebService、TCP等
>
> 消息格式：XML 格式、JSON 格式、定长格式等，报文头长度多少，包含什么内容，每个字段的详细含义。

### 通信端口

MySQL 运行一个服务，监听默认的3306 端口。

### 通信类型

通信类型有两种：同步或者异步

**同步通信的特点：**

1. 同步通信依赖于被调用方，受限于被调用方的性能。即应用操作数据库，线程会阻塞，需要等待数据库的返回。
2. 一般只能做到一对一，很难做到一对多的通信。即应用操作数据库，线程只有在数据库处理完返回后才能再执行下一次操作。

缺点：

1. 当数据库资源缺乏，或者数据库操作需要花费大量时间，会导致应用端要阻塞等待。
2. 连接数有限（连接线程），当所有线程都阻塞处理时，数据库无法与其他应用建立连接。



异步通信的特点：

1. 异步和同步相反，异步可以避免应用阻塞等待（不能节省SQL 执行的时间）。

缺点：

1. 如果异步存在并发，每一个SQL 的执行都要单独建立一个连接，容易导致数据混乱。
2. 一个连接就会创建一个线程，线程间切换会占用大量CPU 资源。
3. 异步通信会增加编码的复杂度。

> 所以一般不建议使用。如果要异步，必须使用连接池，排队从连接池获取连接而不是创建新连接。

**MySQL 可以使用同步/异步的方式，一般来说我们连接数据库都是同步连接。**



### 连接方式

MySQL 既支持短连接，也支持长连接。

短连接：操作完毕以后，马上close 掉。

长连接：保持打开，减少服务端创建和释放连接的消耗，后面的程序访问的时候还可以使用这个连接。一般我们会在连接池中使用长连接。

长连接缺点：保持长连接会消耗内存。

MySQL 对长时间不活动的连接，会将连接断开。

可以通过以下两个参数定义连接超时（默认都是28800 秒，8 小时）：

```sql
show global variables like 'wait_timeout'; -- 非交互式超时时间，如JDBC 程序
show global variables like 'interactive_timeout'; -- 交互式超时时间，如数据库工具Navicat
```



> show 语句注意：
>
> 格式：show (级别) 参数，默认级别使用 session，全局级别需要手动定义为 global。两者区别为：如果我们在 session 级别临时修改了参数，则该参数只在该会话中临时生效，如果对该参数查询 global 级别则会发现参数并未修改。
>
> 动态修改参数注意：
>
> 格式：set (级别) 参数，默认级别使用 session，全局级别需要手动定义为 global。session 级别只会在该会话生效，全局级别会在数据库重启后失效。如果想永久修改参数，需要修改配置文件/etc/my.cnf

### 连接信息

**连接数情况：**

MySQL 实际对每个连接都是用一个线程去处理。

> 我们可以通过 kill 线程去结束连接。

可以用show status 命令查看连接数相关配置：

```sql
show global status like 'Thread%';
```

| 参数              | 作用                                 |
| ----------------- | ------------------------------------ |
| Threads_cached    | 缓存中的线程连接数                   |
| Threads_connected | 当前打开的连接数                     |
| Threads_created   | 为处理连接创建的线程数               |
| Threads_running   | 非睡眠状态的连接数，通常指并发连接数 |



MySQL 最大连接数在5.7 版本中默认是151 个，最大可以设置成16384（2^14）。

可以通过以下 sql 语句查询：

```sql
show variables like 'max_connections';
```



**连接状态：**

可以使用以下sql 查看连接状态：

```sql
SHOW PROCESSLIST;
```

> 如果不是 root 用户，则只能看到自己用户建立的连接状态。

| 状态                         | 含义                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| Sleep                        | 线程正在等待客户端向它发送一个新语句                         |
| Query                        | 线程正在执行查询或往客户端发送数据                           |
| Locked                       | 该查询被其它查询锁定                                         |
| Copying to tmp table on disk | 临时结果集合大于tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器 |
| Sending data                 | 线程正在为SELECT 语句处理行，同时正在向客户端发送数据        |
| Sorting for group            | 线程正在进行分类，以满足GROUP BY 要求                        |
| Sorting for order            | 线程正在进行分类，以满足ORDER BY 要求                        |

### 通信协议

**Unix Socket：**

比如我们在Linux 服务器上，如果没有指定-h 参数，它就用socket 方式登录（省略了-S /var/lib/mysql/mysql.sock）。

该方式不用通过网络协议，也可以连接到MySQL 的服务器，它需要用到服务器上的一个物理文件（/var/lib/mysql/mysql.sock）。

**TCP/IP 协议：**

```sh
mysql -h192.168.8.211 -uroot -p123456
```

如果指定-h 参数用 TCP 协议连接到MySQL 服务器的， 比如mysql-connector-java-x.x.xx.jar。

另外还有**命名管道（Named Pipes）**和**内存共享（Share Memory）**的方式，这两种通信方式只能在Windows 上面使用，一般用得比较少。



### 通信方式

通信方式分为三种：单工、半双工、全双工。

**单工：**

在两台计算机通信的时候，数据的传输是单向的。生活中的类比：遥控器。

**半双工：**

在两台计算机之间，数据传输是双向的，你可以给我发送，我也可以给你发送，但是在这个通讯连接里面，同一时间只能有一台服务器在发送数据，只要有一方在发送数据，另一方只能等待发送方发完后才能发送。生活中的类比：对讲机。

**全双工：**

数据的传输是双向的，并且可以同时传输。生活中的类比：打电话。



MySQL 使用半双工的通信方式。所以在一个连接里，同一时刻，客户端和服务端不能同时发送数据。

由于这种半双工的通信方式，会导致以下问题：

1. 在一个连接里，客户端发送SQL语句给服务端时，由于数据不能分成小块发送，只能一次性发送。当SQL语句数据量很大，会导致报错。比如我们用MyBatis 动态SQL 生成了一个批量插入的语句，插入10 万条数据，values后面跟了一长串的内容，或者where 条件in 里面的值太多，会出现问题。

对于上述问题，我们可以修改配置 `max_allowed_packet` 参数的值（默认是4M），修改最大单通信包大小。

2. 同理，服务端发送大量数据给客户端时，此时会对网络和内存产生大量消耗。

对于上述问题，我们在执行语句时，应当适量的添加条件或者查询时加上limit，实现分批查询。（可以对查询语句先 count 一下，判断数据量是否需要分批查询）



## 查询缓存

MySQL 在8.0 版本之前自带了一个缓存模块。

缓存是把数据以KV 的形式放到内存里面，可以加快数据的读取速度，也可以减少服务器处理的时间。

通过以下SQL查询模块开关参数：

```sql
show variables like 'query_cache%';
```

MySQL 在5.7 版本中，默认关闭该缓存模块。

原因如下：

* MySQL 自带的缓存的应用场景有限，第一个是它要求SQL 语句必须一模一样，中间多一个空格，字母大小写不同都被认为是不同的的SQL。
* 表里面任何一条数据发生变化的时候，这张表所有缓存都会失效，所以对于有大量数据更新的应用，也不适合。

因此对于查询缓存，推荐使用ORM 框架（比如MyBatis 默认开启了一级缓存），或者独立的缓存服务，比如Redis 来处理更合适。



## 解析器(Parser)

我们输入字符串，如何被识别SQL语句？

MySQL 的Parser 解析器主要做的事情是对语句基于SQL 语法进行词法和语法分析



### 词法解析

词法分析就是把一个完整的SQL 语句打碎成一个个的单词。

比如一个简单的SQL 语句：

```sql
select name from user where id = 1;
```

它会打碎成8 个符号，每个符号是什么类型，从哪里开始到哪里结束。

### 语法解析

词法解析后接着就是语法分析，语法分析会对SQL 做一些语法检查，比如单引号有没有闭合，然后根据MySQL 定义的语法规则，根据SQL 语句生成一个数据结构。这个数据结构我们把它叫做**解析树（select_lex）**。

> 任何数据库的中间件，比如Mycat，Sharding-JDBC（用到了Druid Parser），都必须要有词法和语法分析功能，在市面上也有很多的开源的词法解析的工具（比如LEX，Yacc）。



## 预处理(Preprocessor)

虽然SQL语句词法和语法都正确，但如果表名或者字段不存在（语义）也理应当报错。

预处理器(Preprocessor)：它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是
否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。



## 查询优化（Query Optimizer）

### 执行计划

一条SQL 语句是可以有很多种执行方式的，最终返回相同的结果，他们是等价的。MySQL 通过查询优化器（Query Optimizer）根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划。MySQL 优化器会对这些执行计划通过算法算出开销（cost），把开销最小的作为最优的执行计划。

可以使用这个命令查看上一次查询的开销：

```sql
show status like 'Last_query_cost';
```



### 优化器作用

优化器作用举例

1. 当我们对多张表进行关联查询的时候，以哪个表的数据作为基准表。
2. 有多个索引可以使用的时候，选择哪个索引。



实际上，对于每一种数据库来说，优化器的模块都是必不可少的，他们通过复杂的算法实现尽可能优化查询效率的目标。但是优化器也不是万能的，并不是再垃圾的SQL 语句都能自动优化，也不是每次都能选择到最优的执行计划，大家在编写SQL 语句的时候还是要注意。



### 查看执行计划

首先要启用优化器的追踪（默认是关闭的）：

```sql
SHOW VARIABLES LIKE 'optimizer_trace';
set optimizer_trace='enabled=on';
```

> 注意开启优化器的追踪是会消耗性能的，因为开启后会把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭优化器的追踪开关（改成off）。

执行我们想要查看的SQL语句，优化器会将生成的执行计划记录到系统表里，可以通过以下命令查看生成的执行计划：

```sql
select * from information_schema.optimizer_trace\G
```

记录的是一个JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。

* expanded_query 是优化后的SQL 语句。
* considered_execution_plans 里面列出了所有的执行计划。



### 优化结果

优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。

由于优化器并不一定能覆盖所有执行路径，因此不一定能获得所有执行计划，所以不一定是最优的执行计划（相对于获得的执行计划中最优的）。

我们可以通过MySQL自带的工具查看，在SQL 语句前面加上EXPLAIN，就可以看到执行计划的信息：

```sql
EXPLAIN select name from user where id=1;
```

> 注意Explain 的结果不一定是最终执行的方式。



## 存储引擎

### 定义

在关系型数据库里面，数据是放在表Table 里面的。我们可以把这个表理解成Excel 电子表格的形式。所以我们的表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由我们的存储引擎决定的，所以我们也可
以把存储引擎叫做表类型。

在MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。

### 查看存储引擎

```sql
show table status from `ds`;
```

> 也可以通过DDL 建表语句来查看存储引擎。

在MySQL 里面，存储引擎的使用是以表为单位的，可以为每一张表指定使用的存储引擎。而且，创建表之后还可以修改存储引擎。

存储引擎决定数据结构，这些数据最终会存放在指定的路径，可通过以下命令查找存储的路径：

```sql
show variables like 'datadir';
```

默认情况下，每个数据库有一个自己文件夹。

任何一个存储引擎都有一个frm 文件，这个是表结构定义文件。不同的存储引擎存放数据的方式不一样，产生的文件、文件数也不一样，innodb 是一个，memory 没有，myisam 是两个。

### 存储引擎比较

MyISAM 和 InnoDB 是用得最多的两个存储引擎。

在MySQL 5.5 版本之前，默认的存储引擎是MyISAM，它是MySQL 自带的。我们创建表的时候不指定存储引擎，
它就会使用MyISAM 作为存储引擎。MyISAM 的前身是ISAM（Indexed Sequential Access Method：利用索引，顺序存取数据的方法）。

5.5 版本之后默认的存储引擎改成了InnoDB，它是第三方公司为MySQL 开发的。
InnoDB 相对 MyISAM 特点是支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。

可以用这个命令查看数据库对存储引擎的支持情况：

```sql
show engines ;
```

其中有存储引擎的描述和对事务、XA 协议和Savepoints 的支持。

* XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。
* Savepoints 用来实现子事务（嵌套事务）。创建了一个Savepoints 之后，事务就可以回滚到这个点，不会影响到创建Savepoints 之前的操作。



#### MyISAM

应用范围比较小。表级锁定限制了读/写的性能，因此在Web 和数据仓库配置中，它通常用于只读或以读为主的工作。

MyISAM 会生成三个文件。

特点：

* 支持表级别的锁（插入和更新会锁表）。不支持事务。
* 拥有较高的插入（insert）和查询（select）速度。
* 存储了表的行数（count 速度更快）。

使用场景：

* 快速插入大量数据。先用MyISAM 插入数据，然后修改存储引擎为InnoDB 。
* 只读之类的数据分析的项目。



#### InnoDB

mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与ACID 兼容）的MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。

InnoDB 会生成两个文件

特点：

* 支持事务，支持外键，因此数据的完整性、一致性更高。
* 支持行级别的锁和表级别的锁。
* 支持读写并发，写不阻塞读（MVCC）。
* 特殊的索引存放方式，可以减少IO，提升查询效率。



使用场景：

* 经常更新的表，存在并发读写或者有事务处理的业务系统。



#### Memory

将所有数据存储在RAM 中，以便在需要快速查找非关键数据的环境中快速访问。这个引擎以前被称为堆引擎。其使用案例正在减少：InnoDB 及其缓冲池内存区域提供了一种通用、持久的方法来将大部分或所有数据保存在内存中，而ndbcluster 为大型分布式数据集提供了快速的键值查找。

Memory 由于存储在内存中，因此不会生成文件。

特点：

* 把数据放在内存里面，读写的速度很快，但是数据库重启或者崩溃，数据会全部消失。

使用场景：

* 临时表。



#### CSV

它的表实际上是带有逗号分隔值的文本文件。csv 表允许以csv 格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为csv 表没有索引，所以通常在正常操作期间将数据保存在innodb 表中，并且只在导入或导出阶段使用csv 表。

CSV 会生成三个文件

特点：

* 不允许空行，不支持索引。格式通用，可以直接编辑。

使用场景：

* 在不同数据库之间导入导出



#### Archive

这些紧凑的未索引的表用于存储和检索大量很少引用的历史、存档或安全审计信息。

Archive 会生成三个文件

特点：

* 不支持索引，不支持update delete。
* 支持压缩。

使用场景：

* 存储不会改变的数据。



### 存储引擎选择

我们在不同的业务场景中对数据操作的要求不同，就可以选择不同的存储引擎来满足我们的需求，这个就是MySQL 支持这么多存储引擎的原因。

* 如果对数据一致性要求比较高，需要事务支持，可以选择InnoDB。
* 如果数据查询多更新少，对查询性能要求比较高，可以选择MyISAM。
* 如果需要一个用于查询的临时表，可以选择Memory。
* 如果所有的存储引擎都不能满足你的需求，并且技术能力足够，可以根据官网内部手册用C 语言开发一个存储引擎。



## 执行引擎（Query Execution Engine）

执行引擎（Query Execution Engine）根据选择的执行计划，调用存储引擎提供的API进行处理。

> 由于数据库提供多种存储引擎，因此对这些引擎抽象出共同的API，从而屏蔽了具体存储引擎实现的差异性。

处理完成后将数据结果返回给客户端，即使没有结果也要返回。



# 体系结构总结

![MySQL架构](https://raw.githubusercontent.com/Cavielee/notePics/main/MySQL架构.jpg)

1. Connector：用来支持各种语言和SQL 的交互，比如PHP，Python，Java 的JDBC；
2. Management Serveices & Utilities：系统管理和控制工具，包括备份恢复、MySQL 复制、集群等等；
3. Connection Pool：连接池，管理需要缓冲的资源，包括用户密码权限线程等等；
4. SQL Interface：用来接收用户的SQL 命令，返回用户需要的查询结果
5. Parser：用来解析SQL 语句；
6. Optimizer：查询优化器；
7. Cache and Buffer：查询缓存，除了行记录的缓存之外，还有表缓存，Key 缓存，权限缓存等等；
8. Pluggable Storage Engines：插件式存储引擎，它提供API 给服务层使用，跟具体的文件打交道。



## 架构分层

总体上，可以把MySQL 分成三层：

![MySQL架构分层](https://raw.githubusercontent.com/Cavielee/notePics/main/MySQL架构分层.jpg)

### 连接层

我们的客户端要连接到MySQL 服务器3306 端口，必须要跟服务端建立连接，那么管理所有的连接，验证客户端的身份和权限，这些功能就在连接层完成。



### 服务层

连接层会把SQL 语句交给服务层，这里面又包含一系列的流程：

* 查询缓存的判断
* 根据SQL 调用相应的接口，对我们的SQL 语句进行词法和语法的解析（比如关键字怎么识别，别名怎么识别，语法有没有错误等等）。
* 优化器：MySQL 底层会根据一定的规则对我们的SQL 语句进行优化
* 执行器去执行。



### 存储引擎

存储引擎就是我们的数据真正存放的地方，在MySQL 里面支持不同的存储引擎。存储引擎就是将数据存放到内存或者磁盘（硬件）。



# 更新流程

在数据库里面，update 操作其实包括了更新、插入和删除。

> MyBatis 的Executor 里面只有doQuery()和doUpdate()的方法，没有doDelete()和doInsert()。

更新流程和查询流程基本一致，都要经过解析器、优化器的处理，最后交给执行器。区别就在于拿到符合条件的数据之后的操作。



## 缓冲池（Buffer Pool）

InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页（数据）放到一块内存区域里面。这个内存区域就叫Buffer Pool。

下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。

**修改数据的时候，先修改缓冲池里面的页。**

当内存的数据页和磁盘数据不一致的时候，我们把它叫做**脏页**。InnoDB 里面有专门的后台线程把Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。



## InnoDB 内存结构和磁盘结构

Buffer Pool 是InnoDB 里面非常重要的一个结构，它的内部又分成几块区域。下面是InnoDB 的内存结构和磁盘结构：

![InnoDB内存结构和磁盘结构](https://raw.githubusercontent.com/Cavielee/notePics/main/InnoDB内存结构和磁盘结构.jpg)

### 内存结构

内存结构主要分为4个部分：

 `Buffer Pool`、`Change Buffer`、`Adaptive Hash Index`、`(redo)log buffer`。



#### Buffer Pool

Buffer Pool 缓存的是页面信息，包括数据页、索引页。

查看服务器状态和参数：，可以看到Buffer Pool 相关的信息即配置：

```sql
SHOW STATUS LIKE '%innodb_buffer_pool%';
SHOW VARIABLES like '%innodb_buffer_pool%';
```

> Buffer Pool 默认大小是128M（134217728 字节），可以调整。

InnoDB 用LRU算法来管理缓冲池（链表实现，不是传统的LRU，分成了young 和old），经过淘汰的数据就是热点数据。

内存缓冲区对于提升读写性能有很大的作用。



#### Change Buffer 写缓冲

如果更新操作要操作的数据页在 Buffer Pool 已经缓存了，那就可以直接对其更新。否则，只能从磁盘IO中先加载到内存再处理（会有IO消耗），当数据页是二级索引页时，数据存储不是有序的，因此磁盘I/O 会更大。对于这种情况提供了进一步优化：

如果修改操作使用的是非唯一索引，会先把修改记录在Change Buffer中，从而提升更新语句（Insert、Delete、Update）的执行速度。

当再次访问这个数据页、或者通过后台线程、或者数据库shut down、或者redo log 写满时，会将Change Buffer 记录合并到数据页，并稍后由后台线程对修改的数据进行刷脏。

如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用Change Buffer（写缓冲）。我们可以适当调大该缓存区大小，下面是查看该部分缓冲区大小的命令：

```sql
SHOW VARIABLES LIKE 'innodb_change_buffer_max_size';
```

> 参数数值代表 Change Buffer 占Buffer Pool 的比例，默认25%。



#### Adaptive Hash Index

自适应哈希索引。对于一些热点数据页，InnoDB 会自动建立自适应 Hash 索引，也就是在B+Tree 索引基础上建立Hash 索引，从而可以快速查找到 buffer pool 中的数据页。



#### Log Buffer（redo log）

事务的持久性：对于事务提交之后，那么事务中对数据的修改一定要全部保存下来。

事务中的操作会写到 log buffer 中，默认当事务提交会把 log buffer 写到磁盘日志文件中，从而确保事务提交后的操作能够执行。

问题情景：

* 数据页在内存中修改了（Buffer Pool 里面的脏页）但还没有刷入磁盘时，数据库宕机或者重启，脏页的数据会丢失。
* 数据页刷入磁盘时，只写了一部分，导致数据页数据丢失，不可用。

为了避免上述问题，InnoDB 通过**WAL** 技术（Write-Ahead Logging），每执行一条更新语句后，会将该操作对应的xxxx页修改了xxx记录（物理日志）在 log buffer中，然后再根据适当的时机（默认是事务提交时）将 log buffer的记录刷盘到 redo log日志文件中。

从而确保了即使发生上述问题，也可以通过 redo log将数据也进行恢复（确保事务对数据的修改持久化），即实现了 crash-safe。

这个文件就是磁盘的redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和ib_logfile1，每个48M。



**redo log特点：**

1. redo log 是InnoDB 存储引擎实现的，并不是所有存储引擎都有。
2. 不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志**（xxxx页修改了xxx）**。
3. log buffer 的大小是固定的，前面的内容会被覆盖。（有两个指针write pos 跟check point，check point 是当前要覆盖的位置。当两个指针重叠时，说明redo log 已经写满，这时候需要同步redo log 到磁盘中。）



redo log相关配置参数：

```sql
show variables like 'innodb_log%';
```

| 参数                      | 含义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| innodb_log_file_size      | 指定每个文件的大小，默认48M                                  |
| innodb_log_files_in_group | 指定文件的数量，默认为2                                      |
| innodb_log_group_home_dir | 指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。 |

为什么不直接将数据写到存储文件（DB File）中？

磁盘的最小组成单元是扇区，通常是512 个字节。

操作系统和内存打交道，最小的单位是页Page。

操作系统和磁盘打交道，读写磁盘，最小的单位是块Block。

如果要查找数据，需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块
数据，依次进行此过程直到找完所有数据。

随机I/O：数据是随机分散在不同页的不同扇区中，因此每次读写都需要进行多次磁臂旋转等一些列操作找到对应的数据。

顺序I/O：数据有序的存放，使得只要一次磁臂旋转找到第一块数据，其他所需的数据就紧跟后面，可以依次拿到后面所需的数据。

DB 存储文件采用的是随机 I/O（二级索引回表是随机I/O）。

日志记录采用的是顺序I /O，顺序I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。当然 redo log 也不是每一次都直接写入磁盘，在Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认16M，它一样可以节省磁盘IO。可以通过命令查看redo log 内存缓存区大小：

```sql
SHOW VARIABLES LIKE 'innodb_log_buffer_size';
```

redo log 写入磁盘的是修改操作，主要是用于崩溃恢复，不是写入数据文件。磁盘的数据文件，数据来自Buffer pool写入。

写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。

log buffer 写入磁盘的时机，由一个参数控制：

```sql
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';
```

| 值                          | 含义                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 0（延迟写，写的时候同时刷） | log buffer 将每秒一次地写入log file 中，并且log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。 |
| 1（默认，实时写，实时刷）   | 每次事务提交时MySQL 都会把log buffer 的数据写入log file，并且刷到磁盘中去。 |
| 2（实时写，延迟刷）         | 每次事务提交时MySQL 都会把log buffer 的数据写入log file。但是flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次flush 操作。 |

![redo log写入](https://raw.githubusercontent.com/Cavielee/notePics/main/redo log写入.jpg)

### 磁盘结构

磁盘结构里面主要是各种各样的表空间，叫做Table space。表空间可以看做是InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为5 大类。



#### 系统表空间

在默认情况下InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。

InnoDB 系统表空间包含InnoDB 数据字典、双写缓冲区，Change Buffer 、Undo Logs，如果没有指定file-per-table，也包含用户创建的表和索引数据。

1. undo 在后面介绍，因为有独立的表空间。
2. 数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。
3. 双写缓冲（InnoDB 的一大特性）：InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为16K，操作系统页大小为4K，InnoDB 的页写入到磁盘时，一个页需要分4 次写。

![双写缓冲](https://raw.githubusercontent.com/Cavielee/notePics/main/双写缓冲.jpg)

如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。

```sql
show variables like 'innodb_doublewrite';
```

由于上述问题，导致数据页损坏（因为只有一部分数据写了而导致数据丢失），所以当出现上述情况时，此时用 redo log 对损坏的数据页进行崩溃恢复是没有意义的，因此在使用 redo log 对损坏的数据页进行崩溃恢复时，此时会写入失效，需要使用该数据页的副本对该数据页进行还原，然后再继续使用 redo log 对数据页的崩溃恢复。

这个数据页的副本就是double write，InnoDB 的双写技术（在写入数据页前会将副本写入来保证写入失败也能使用该副本还原）。通过它实现了数据页的可靠性。double write 由两部分组成，一部分是内存的double write，一个部分是磁盘上的double write。因为double write 是顺序写入的，不会带来很大的开销。

在默认情况下，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。

#### 独占表空间

独占表空间（file-per-table tablespaces），如果将所有表和索引都放在系统表空间存放，这样导致该文件会越来越大。

因此可以让每张表独占一个表空间。这个开关通过innodb_file_per_table 设置，默认开启。

```sql
SHOW VARIABLES LIKE 'innodb_file_per_table';
```

开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的ibd 文件（例如/var/lib/mysql/ds/user_innodb.ibd），存放表的索引和数据。

但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，双写缓冲（Double write buffer）等还是存放在原来共享的系统表空间。



#### 通用表空间

通用表空间（general tablespaces），是一种共享的表空间，跟ibdata1 类似。可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：

```sql
create tablespace ts2673 add datafile '/var/lib/mysql/ts2673.ibd' file_block_size=16K engine=innodb;
```

在创建表的时候可以指定表空间，用ALTER 修改表空间可以转移表空间。

```sql
create table t2673(id integer) tablespace ts2673;
```

不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：

```sql
drop table t2673;
drop tablespace ts2673;
```



#### 临时表空间

临时表空间（temporary tablespaces），存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。



#### Redo log

磁盘结构里面的redo log，在前面已经介绍过了。



#### undo log

undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括select）。如果修改数据时出现异常，可以用 undo log 来实现回滚操作（确保事务的原子性）。

在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志。

redo Log 和undo Log 与事务密切相关，统称为事务日志。

undo Log 的数据默认在系统表空间ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个undo 表空间。

```sql
show global variables like '%undo%';
```



## 后台线程

后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。

后台线程大致分为：

* **master thread：**负责刷新缓存数据到磁盘并协调调度其它后台进程。
* **IO thread：**分为change buffer、log、read、write 进程。分别用来处理change buffer、redo log、读写请求的IO 回调。
* **purge thread：**用来回收 undo 页。
* **page cleaner thread：**用来刷新脏页。



## Binlog

除了InnoDB 架构中的日志文件，MySQL 的Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。

事务提交的时候会将更新操作语句记录在 binlog，（由于它记录的是 SQL 语句，属于逻辑日志）。

跟redo log 不一样，它的文件内容是可以追加的，没有固定大小限制。



### 使用场景

* 把 binlog 导出成SQL 语句，把所有的操作重新执行一遍，来实现数据的恢复。
* 实现主从复制，从服务器读取主服务器的binlog，然后执行一遍。



### 刷盘机制

通过 `sync_binlog` 参数控制 biglog 的刷盘时机，取值范围是 `0-N`：

- 0：不去强制要求，由系统自行判断何时写入磁盘；
- 1：每次 `commit` 的时候都要将 `binlog` 写入磁盘；
- N：每N个事务，才会将 `binlog` 写入磁盘。

MySQL 5.7.7 之后默认值是 1，实际使用时可以适当增加该值从而提升数据库性能，以牺牲一定的一致性来获取更好的性能。

配置方式和主从复制的实现原理在Mycat 中有讲述。

## 总结

案例：将name为Cavie修改为Cavie1的更新流程：

```sql
update user set name = 'Cavie1' where id=1;
```

1. 事务开始，从内存或磁盘取到这条数据，返回给Server 的执行器；
2. 执行器调用存储引擎接口修改内存数据，将这行数据改为Cavie1（根据配置来决定写入磁盘时机）；
3. 记录name=Cavie到undo log；
4. 记录name=Cavie1到redo log（redo log 进入prepare 状态）；
5. 写入binlog ，并把binlog写入磁盘。（如果开启了binlog）清除对应 undo log，将 redo log设置为 commit 状态。
6. 事务提交。

> 在上面操作流程中，内存和磁盘之间，还有许多后台线程在运行。如事务提交后，可能会写入数据到日志文件，也可能会进行将数据刷盘