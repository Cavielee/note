# 定义

数据库索引，是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询、更新数据库表中数据。

数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。

如果没有索引的话，要从500 万行数据里面检索一条数据，只能依次遍历这张表的全部数据，直到找到这条数据。这就意味这要进行许多次IO操作，消耗大量时间。

索引是一种特殊的专门用来快速检索的数据结构，通过索引我们可以快速找到数据对应的磁盘地址在哪，就可以找到我们所需的数据。而不是将表顺序遍历查找每行数据。

可以将索引理解为书本的目录，想要知道某个小节，不是从第一页开始每页查找，而是通过书本目录快速定位到我们想要的小节在哪一页。



# 索引类型

在 InnoDB 里面，索引类型有三种，普通索引、唯一索引（主键索引是特殊的唯一索引）、全文索引。

* **普通（Normal）：**也叫非唯一索引，是最普通的索引，没有任何的限制。
* **唯一（Unique）：**唯一索引要求键值不能重复。另外需要注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用primay key创建。
* **全文（Fulltext）：**针对比较大的数据，比如我们存放的是消息内容，有几KB 的数据的这种情况，如果要解决like 查询效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char、varchar、text。

> MyISAM 和InnoDB 都支持全文索引



# InnoDB 逻辑存储结构

MySQL 的存储结构分为5 级：表空间、段、簇、页、行。

![Mysql存储结构](https://raw.githubusercontent.com/Cavielee/notePics/main/Mysql存储结构.jpg)

## 表空间（Table Space）

表空间可以看做是InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。分为：系统表空间、独占表空间、通用表空间、临时表空间、Undo 表空间。



## 段（Segment）

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等，段是一个逻辑的概念。一个ibd 文件（独立表空间文件）里面会由很多个段组成。

创建一个索引会创建两个段：

* 索引段：leaf node segment，索引段管理非叶子节点的数据。
* 数据段：non-leaf node segment，数据段管理叶子节点的数据。

也就是说，**一个表的段数，就是索引的个数乘以2。**



## 簇（Extent）
一个段（Segment）又由很多的簇（也可以叫区）组成，每个区的大小是1MB（64个连续的页）。

每一个段至少会有一个簇，一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。



## 页（Page）
为了高效管理物理空间，对簇进一步细分，就得到了页。

簇是由连续的页（Page）组成的空间，一个簇中有64 个连续的页。（1MB／16KB=64）。这些页面在物理上和逻辑上都是连续的。

跟大多数数据库一样，InnoDB 也有页的概念（也可以称为块），**每个页默认16KB。**页是InnoDB 存储引擎磁盘管理的最小单位，通过 `innodb_page_size` 设置页的大小。

一个表空间最多拥有2^32 个页，默认情况下一个页的大小为16KB，也就是说一个表空间最多存储64TB 的数据。



文件系统中，也有页的概念。操作系统和内存打交道，最小的单位是页Page。文件系统的内存页通常是4K。

![读取数据](https://raw.githubusercontent.com/Cavielee/notePics/main/读取数据.jpg)

> 从上图可以看到将一页的数据写入到文件系统，实际上是分了四次写入。



## 总结

* 表空间：包含多张表，每张表包含多个段；表空间最多拥有2^32 个页，即表空间最大容量为64TB
* 段：每个段包含多个区，一个索引会有两个段（索引管理段和数据管理段）
* 簇（区）：每个区有64页（默认一页16KB，即一个区1 MB）
* 页：每个页默认16KB，页是InnoDB 存储引擎磁盘管理的最小单位。通过页来跟文件系统交互。



# 索引数据结构演进

## 二分查找

对于**有序数据存储**作为索引的数据结构，我们可以想到使用二分查找的方法，每次查找都会将候选数据减少一半。

**有序数据存储**的结构常见的有两种：数组和链表

对于数组来说，等值查询和比较查询效率非常高，但是更新数据的时候会出现一个问题，可能要挪动大量的数据（改变index），所以只适合存储静态的数据。

对于链表来说，插入/删除数据效率非常高，但查询数据只能顺序查找。



## 二叉查找树（BST Binary Search Tree）

二叉查找树（BST ）特点：

左子树所有的节点都小于父节点，右子树所有的节点都大于父节点。

![二叉查找树](https://raw.githubusercontent.com/Cavielee/notePics/main/二叉查找树.jpg)

使用二叉查找树（BST ）既能像链表那样快速的插入删除节点，而且也使用了类似二分查找的原理，减少了查询次数，提高查询效率。

**二叉查找树有一个问题：**

查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。

即当正序或反序插入数据时，此时树会变成链表形式（又称`斜树`），此时查询数据跟链表顺序查询没有区别，查询效率会很慢。



## 平衡二叉树（AVL Tree）

对于二叉查找树（BST）来说，在特殊情况会出现`斜树`的问题是因为他没有一种平衡的操作，导致左右树深度相差很大，查询次数多，效率低。

而平衡二叉树（AVL）正是解决这问题的一种优化数据结构。

**平衡二叉树的定义：左右子树深度差绝对值不能超过1。**比如左子树的深度是2，右子树的深度只能是1 或者3。

当发现证左右子树的深度差超过1时，会进行左旋/右旋（替换根节点，使左右子树平衡）的操作将左右子树深度差变为1。

![AVL右旋](https://raw.githubusercontent.com/Cavielee/notePics/main/AVL右旋.jpg)

![AVL左旋](https://raw.githubusercontent.com/Cavielee/notePics/main/AVL左旋.jpg)

> 当然删除节点，会对其重新进行平衡。



### 索引存储内容

在平衡二叉树中，一个节点，它的大小是一个固定的单位，作为索引应该存储什么内容？

它应该存储三块的内容：

* 索引的键值。比如我们在id 上面创建了一个索引，我在用where id =1 的条件查询的时候就会找到索引里面的id 的这个键值。
* 数据的磁盘地址，因为索引的作用就是避免我们直接去磁盘顺序查找（减少IO操作），而是通过索引定位到数据的存放的物理地址。
* 数据结构是二叉树，它必须有左子节点和右子节点的引用，通过左右子节点来将候选数据缩减，通过左右子节点的引用才能往下走继续判断查找出我们要的键值的节点。

![二叉树索引存储结构](https://raw.githubusercontent.com/Cavielee/notePics/main/二叉树索引存储结构.jpg)

从上面逻辑存储结构可以知道，假设一条数据大小为1kB，那么一页就可以放16条数据。

> InnoDB 存储引擎是面向行的（row-oriented），也就是说数据的存放按行进行存放。



### 平衡二叉树索引不足

查看数据和索引的大小：

```sql
select
CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS data_len,
CONCAT(ROUND(SUM(INDEX_LENGTH/1024/1024),2),'MB') as index_len
from information_schema.TABLES
where table_schema='ds' and table_name='user_innodb';
```

当我们用树的结构来存储索引的时候，访问一个节点就要跟磁盘之间发生一次IO。

而 InnoDB 操作磁盘的最小的单位是一页，大小是16KB。因此我们应该定义一个树的节点就是16K 的大小（访问一个节点就读 InnoDB 最小操作磁盘单位一页）。

存在问题：

如果一个节点只存一个键值+数据+引用（一条数据），可能只能用到几十个字节，远远达不到16 KB，造成大量的空间浪费。一个节点数据量越少，那么就意味着节点的数量会很多，导致树的层数越多（越深）。层数越多意味着查询一条数据 IO 操作可能会更多（每访问一个节点就需要一次IO操作，IO操作是十分耗时的）。



## 多路平衡查找树（B Tree）

为了解决平衡二叉树作为索引的缺陷，进而提出了多路平衡二叉树（Balance Tree）。

其特点是：基于平衡二叉树，对每个节点存储更多的数据。由于节点的关键字数据越多，那么就意味着节点的子节点会更多，形成了更多的分叉（也称为路数）

由于分叉数增多，那么树的深度也就相对的减少，IO操作次数也就减少。

**定义：**分叉数（路数）永远比关键字数多1。如下图，一个节点关键字数为2，那么其路数就会有三条。

![BTree](https://raw.githubusercontent.com/Cavielee/notePics/main/BTree.jpg)

### B Tree 和 AVL区别

当我们插入数据时，如果超过了我们定义的关键字数量，会进行分裂（拆分节点）。分裂后因为要符合定义：路数要比关键字数多1：

![BTree分裂](https://raw.githubusercontent.com/Cavielee/notePics/main/BTree分裂.jpg)

同理，当我们删除节点时，此时不符合定义：路数要比关键字数多1，需要对路数进行往上合并。

> 可以看出在更新索引的时候会有大量的索引的结构的调整，所以建议不要在频繁更新的列上建索引，或者对主键更新。
> 节点的分裂和合并，其实就是InnoDB 页的分裂和合并（因为一个节点的大小正是我们页的大小）。



## B+树（加强版多路平衡查找树）

![B+树](https://raw.githubusercontent.com/Cavielee/notePics/main/B+树.jpg)

B+Tree 特点：

1. 关键字的数量是跟路数相等的；

2. B+Tree 只有叶子节点才存储数据，其他节点只存关键字和子节点引用。搜索到关键字不会直接返回，会到最后一层的叶子节点。比如搜索id=28，虽然在第一层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜索，一直到叶子节点。

   基于第二个特点，可以得知，使用索引搜索任意一个值，其耗时基本一致，因为访问的节点数都是相同的（都要访问到叶子节点），所以也体现了索引查询效率的稳定（不会出现查询某个值几秒，查询另一个值十几秒的现象）。

   假设一条记录是1KB，那么一个叶子节点就可以存储16条数据。

   非叶子节点大小为索引关键字+引用指针，假设索引关键字是bigint 类型，长度为8 字节。指针大小在InnoDB 源码中设置为6 字节。由于B+Tree 保留B Tree的特点，关键字数和路数数量一致，那么一个非叶子节点（一页）可以存储`16384/14=1170` 个这样的单元（键值+指针），代表有1170 个指针。
   当树深度为2 的时候， 有1170^2 个叶子节点， 可以存储的数据为`1170*1170*16=21902400`。

   可以看到在InnoDB 中B+ 树深度一般为1-3 层（每一层代表一次IO磁盘访问），它就能满足千万级的数据存储。

3. B+Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。

   基于第三个特点，可以得知，当需要范围查询的时候，只需获得第一个数据，其余数据只需要延后即可（因为是有序的链表）

4. 它是根据左闭右开的区间[ )来检索数据。

   比如我们要查找28，在根节点就找到了键值，但是因为它不是页子节点，所以会继续往下搜寻，28 是[28,66)的左闭右开的区间的临界值，所以会走中间的子节点，然后继续搜索，它又是[28,34)的左闭右开的区间的临界值，所以会走左边的子节点，最后在叶子节点上找到了需要的数据。



特点总结：

1. 基于B Tree，而且解决了B Tree缺点（每个节点存储更多的关键字，路数更多）
2. 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵B+Tree 拿到所有的数据）
3. B+Tree 的磁盘读写能力相对于B Tree 来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
5. 效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以IO 次数是稳定的）



## 红黑树

红黑树也是BST 树，但**不是严格平衡的，因此索引不用红黑树数据结构**。

红黑树定义：

1. 节点分为红色或者黑色。
2. 根节点必须是黑色的。
3. 叶子节点都是黑色的NULL 节点。
4. 红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。
5. 从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点。

基于以上规则，可以推导出：
从根节点到叶子节点的最长路径（红黑相间的路径）不大于最短路径（全部是黑色节点）的2 倍。
由于只有两路、不够平衡，所以索引不用该数据结构。红黑树一般只放在内存里面用。例如Java 的TreeMap。



## 使用注意

### 索引列选择

在更新索引的时候会有大量的索引的结构的调整，如节点的分裂和合并。从而导致指针重指向，修改物理分配的存储空间（节点的分裂和合并，其实就是InnoDB 页的分裂和合并）。

因此建议不要在频繁更新的列上建索引，或者对主键（主键本身就是索引）更新。
（因为一个节点的大小正是我们页的大小）。

### 有序存储数据

往表中插入数据时，如果一个页已经写完，产生一个新的页。如果一个簇的所有的页都被用完，会从当前页所在段新分配一个簇。

如果数据不是连续的，往已经写满的页中插入数据，会导致页分裂（数据在页中位置往后挪）

因此建议我们存储数据最好是有序的，自增的，这样就会减少页分裂的情况，从而避免页分裂的消耗以及数据空间利用率更高。

# 索引数据结构

在Navicat 的工具中，可以看到索引的数据类型有两种，Hash 和B+ Tree。

HASH特点：使用Hash算法，直接算出数据的地址，时间复杂度是O(1)，查询速度比较快。

但Hash也存在以下问题：

1. 不支持范围查询，对于范围查询，实际是将每一个值都hash算出数据地址，时间复杂度是O(n)，查询速度慢。
2. 如果字段重复值很多的时候，会出现大量的哈希冲突（可以采用拉链法解决，但效率还是低），效率会降低。



实际上在 InnoDB 创建索引时，即使使用 Hash 数据结构创建，最终还是创建 B+ Tree 数据结构。原因如下：

**InnoDB 内部使用哈希索引来实现自适应哈希索引特性。**

InnoDB 内存结构可以看到 buffer pool 里面有一块区域是Adaptive Hash Index 自适应哈希索引。对于一些热点数据页，InnoDB 会自动建立自适应 Hash 索引，也就是在B+Tree 索引基础上建立Hash 索引，这个过程对于客户端是不可控制的，隐式的。

通过下面的命令可以看到，自适应哈希索引默认是开启的：

```sql
show variables like 'innodb_adaptive_hash_index';
```



# MyISAM 和InnoDB 索引区别

MySQL 的数据都是文件的形式存放在磁盘中的，每个数据库都会创建对应的文件夹，分别使用MyISAM 和 InnoDB 创建表。可以看到，每张InnoDB 的表有两个文件（.frm 和.ibd），MyISAM 的表有三个文件（.frm、.MYD、.MYI）。

.frm 是MySQL 里面表结构定义的文件，不管你建表的时候选用任何一个存储引擎都会生成。



## MyISAM

在MyISAM 里面，另外有两个文件：

* .MYD 文件，D 代表Data，是MyISAM 的数据文件，存放数据记录，比如user_myisam 表的所有的表数据。
* .MYI 文件，I 代表Index，是MyISAM 的索引文件，存放索引，比如在id 字段上面创建了一个主键索引，那么主键索引就是在这个索引文件里面。

所以在MyISAM 里面，索引和数据是两个独立的文件。

MyISAM 的B+Tree 里面，叶子节点存储的是数据文件中数据对应的磁盘地址。所以从索引文件.MYI 中找到键值后，会到数据文件.MYD 中获取相应的数据记录。

![MyISAM索引流程](https://raw.githubusercontent.com/Cavielee/notePics/main/MyISAM索引流程.jpg)

上面的是主键索引（主键作为索引关键字）。

对于MyISAM 辅助索引（主键以外的字段作为索引关键字），其跟主键索引查找数据的流程没有区别，辅助索引也会建一个B+ 树的数据结构存放在.MYI 文件中。



## InnoDB

InnoDB 只有一个文件（.ibd 文件），它是以主键为索引来组织数据的存储的，所以索引文件和数据文件是同一个文件，都在.ibd 文件里面。

在InnoDB 的主键索引的叶子节点上，它直接存储了我们的数据。

![InnoDB索引流程](https://raw.githubusercontent.com/Cavielee/notePics/main/InnoDB索引流程.jpg)

### 聚簇索引

聚集索引（聚簇索引）索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。

在InnoDB 里面，它组织数据的方式叫做（聚集）索引组织表（clustered indexorganize table），所以主键索引是聚集索引，非主键都是非聚集索引。

对于InnoDB 辅助索引（非聚集索引），其叶子节点存储的不是数据，而是该数据对应的主键值。即通过辅助索引获得主键值再去主键索引获取数据。

由于前面所说B+ Tree节点插入或者删除时，会出现分裂/合并操作。所以如果辅助索引不存主键值，而是直接存储主键值的磁盘地址，出现分裂/合并就会导致存储的主键值的磁盘地址发生变化，频繁修改这些磁盘地址会消耗更大，因此存储主键值，就不用担心上述的问题。



### 主键索引问题

由于InnoDB 是根据主键索引去查找数据，因此InnoDB 会有以下操作：

1. 如果我们定义了主键(PRIMARY KEY)，那么InnoDB 会选择主键作为聚集索引。

2. 如果没有显式定义主键，则InnoDB 会选择第一个不包含有NULL 值的唯一索引作为主键索引。

3. 如果也没有这样的唯一索引，则InnoDB 会选择内置6 字节长的ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。可通过以下命令查看这个隐藏字段：

   ```sql
   select _rowid name from table_name;
   ```

   

# 索引使用原则

并不是所有字段都适合建索引，并不是索引越多越好。以下是建立索引应该考虑的情况：

## 字段的离散度

离散度的公式：`count(distinct(column_name)) : count(*)`，列的全部不同值和所有数据行的比例。

数据行数相同的情况下，分子越大，列的离散度就越高。

简单来说，如果列的重复值越多，离散度就越低，重复值越少，离散度就越高。

如果辅助索引字段有大量重复值，那么就意味着查询出来的主键值会有很多，导致需要扫描的数据行数就更多，这查询效率低。

下面是对user表的name字段建立索引，并对查询进行分析：

```sql
ALTER TABLE user_innodb ADD INDEX idx_user_name (name);
EXPLAIN SELECT * FROM `user_innodb` WHERE name = 'Cavie';
```

rows 字段表示预计需要扫描的行数。

因此我们推荐索引字段离散度要大（重复值少）



## 联合索引最左匹配

有的时候查询会有多个多条件筛选，这时候我们应该建立联合索引，而不是单索引。

> 单列索引可以看成是特殊的联合索引。

比如我们在user 表上面，给name 和phone 建立了一个联合索引。

```sql
ALTER TABLE user_innodb add INDEX comidx_name_phone (name,phone);
```

![联合索引](https://raw.githubusercontent.com/Cavielee/notePics/main/联合索引.jpg)

联合索引在B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的（name 在左边，phone 在右边）。

从这张图可以看出来，name 是有序的，phone 是无序的。当name 相等的时候，phone 才是有序的。

对于联合索引，查询条件一定要有最左边的关键字段，因为联合索引一开始只能依据左边关键字段去判断筛选节点，如果没有最左边的关键字段，就无法确定下一步应该往那个分叉走。

如上面例子，条件一定要包含name字段，不然只能全表扫描。

假如联合索引有三个关键字(a,b,c)，实际上等同于创建了三个索引index(a)，index(a,b)，index(a,b,c)。

用where b=? 和where b=? and c=? 和where a=? and c=?是不能使用到索引的。不能不用第一个字段，不能中断。

因此会出现下面情景：

对于查询慢的两个语句建立索引进行优化：

```sql
SELECT * FROM user_innodb WHERE name= ? AND phone = ?;
SELECT * FROM user_innodb WHERE name= ?;
```

此时我们不必创建index(name, phone) 和 index(name)，因为联合索引index(name, phone) 实际也包括了索引index(name) 作用。



## 覆盖索引

回表：使用辅助索引查找出主键值，然后根据主键值到主键索引中查找到我们所需的数据，这个过程就叫回表。

覆盖索引：查询的字段，如果能从辅助索引直接获得，并不用回到主键索引查找正一行数据，避免回表，这种就叫覆盖索引。例如：

```sql
SELECT name FROM user_innodb WHERE name= ? AND phone = ?;
```

通过联合索引index(name,phone)，上面这条查询语句实际可以在联合索引中获得所需数据name，从而避免了回表到主键索引查找数据。

通过分析查询语句，如果有使用到覆盖索引，在Extra字段会额外显示 `Using  index`：

```sql
EXPLAIN SELECT name FROM user_innodb WHERE name= 'Cavie' AND phone = ' 13666666666';
```

> 前提是查询时，会使用到辅助索引

覆盖索引避免了在主键索引查询的IO操作，从而提高了查询效率。



## 索引条件下推（ICP）

```sql
select * from employees where last_name='Zhang' and first_name LIKE 'feng%' ;
```

对上面的建立了联合索引 index(last_name, first_name)

假设有三个姓Zhang的员工，并只有一个是以feng名字结尾的。

对于这条SQL 有两种执行方式：

1. 根据联合索引查出所有姓Zhang 的二级索引数据，然后回表，到主键索引上查询全部符合条件的数据（3 条数据）。然后返回给Server 层，在Server 层过滤出名字以feng 结尾的员工。
2. 根据联合索引查出所有姓Zhang 的二级索引数据（3 个索引），然后从二级索引中筛选出first_name 以feng 结尾的索引（1 个索引），然后再回表，到主键索引上查询全部符合条件的数据（1 条数据），返回给Server 层。

第一种方式：只用到 last_name 索引，但 first_name 没有用到索引，查出了三条符合数据结果的主键值，然后根据主键值从主键索引查找出数据（磁盘中对这三条数据进行了查找），最后交由 server 层去对这三条数据进行进一步比较判断得出结果数据一条。

第二种方式：只用到 last_name 索引，查出了三条符合数据结果的主键值。此时预先根据另一个关键字段 first_name 对这三条进行比较判断筛选出一条符合的，然后拿着这个主键值从主键索引查找出数据（磁盘中对这一条数据进行了查找），最后交由 server 层直接返回即可。

可以看出第二种方式查询效率更高，因为提前在辅助索引中筛选了数据，从而减少了从主键索引查找数据量，减少了磁盘操作的次数，也不用在server层进行比较判断。

对于第二种方式，我们称为索引条件下推（Index Condition Pushdown）。将 `Like '%feng'` 的判断提前在辅助索引中比较判断，减少了磁盘磁盘操作。而不是从主键索引获取所有符合的数据，然后在server层进行比较判断。

> 索引条件下推只能作用于辅助索引（二级索引）。
>
> ICP 的目标是减少访问表的完整行的读数量从而减少I/O 操作。

在5.6 版本后，InnoDB 默认会开启索引条件下推（Index Condition Pushdown）：

```sql
show variables like 'optimizer_switch';
```

在开启索引条件下推时，如果使用到了，Explain 分析查询语句时 Extra 中会显示`Using Index condition`。

可以通过以下命令关闭：

```sql
set optimizer_switch='index_condition_pushdown=off';
```

关闭后，就会以第一种方式去执行查询，此时Explain 分析查询语句时 Extra 中会显示`Using where`。



## 前缀索引

当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。

此时应当截取多少个字符作为索引？

可通过离散度来判断截取字段数是否合适：

```sql
select count(distinct col) / count(*) from table_name;
-- 下面是尝试截取左边10个字符，可以修改截取字符数
select count(distinct left(col, 10))/count(*) from table_name;
```

通过修改截取字符数，得出离散度与不截取的离散度对比，找出相对索引字符数较少且离散度相近的作为前缀索引。



# 索引创建

索引对于改善查询性能的作用是巨大的，所以我们的目标是尽量使用索引。



## 创建注意

1. 对于常用的where 判断、order 排序、和join on 的字段上创建索引
2. 索引的个数不要过多。——浪费空间，更新变慢。
3. 区分度低的字段，例如性别，不要建索引。——离散度太低，导致扫描行数过多。
4. 频繁更新的值，不要作为主键或者索引。——页分裂
5. 组合索引把散列性高（区分度高）的值放在前面。
6. 创建复合索引，而不是修改单列索引。
7. 不建议使用UUID 等无序的数作为主键。——页分裂
8. 长度较长的字段建议使用前缀索引/全文索引



**建表时创建：**

索引可以在创建表（CREATE TABLE）的同时创建。

```sql
CREATE TABLE user (
	id INT AUTO_INCREMENT COMMENT 'id',
    name VARCHAR (128) COMMENT '用户名',
    projectid INT COMMENT '项目id;此列受project表中的id列约束',
	-- 主键本身也是一种索引（注:也可以在上面的创建字段时使该字段主键自增）
    PRIMARY KEY (id),
	-- 主外键约束（注:project表中的id字段约束了此表中的projectid字段）
	FOREIGN KEY (projectid) REFERENCES project (id),
	-- 给projectid字段创建了唯一索引(注:也可以在上面的创建字段时使用unique来创建唯一索引)
	UNIQUE INDEX (projectid),
	-- 给fileuploadercode字段创建普通索引
	INDEX (fileuploadercode)
	-- 指定使用INNODB存储引擎(该引擎支持事务)、utf8字符编码
) ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT '项目附件表';
```



**修改语句：**

创表后可以使用

`ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；`

```sql
-- 给user表中的id创建索引
ALTER TABLE user ADD UNIQUE INDEX (id);

-- 将id列设置为主键，主键也是一种索引
ALTER TABLE user ADD PRIMARY KEY(id) ;
```



**直接创建索引：**

创表后可以使用

`CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名 ON 表名(字段名) [USING 索引方法]；`

```sql
CREATE UNIQUE INDEX id_index ON user (id)
```



# 索引删除

可利用ALTER TABLE或DROP INDEX语句来删除索引。

```sql
DROP INDEX index_name ON talbe_name

ALTER TABLE table_name DROP INDEX index_name

ALTER TABLE table_name DROP PRIMARY KEY
```



# 索引使用

下面的情况会用不到索引：

1. 索引列上使用函数（replace\SUBSTR\CONCAT\sum count avg）、表达式、计算（+ - * /）：

```sql
explain SELECT * FROM `t2` where id+1 = 4;
```

2. 字符串不加引号，出现隐式转换

```sql
-- 用不到，因为转换成数字去比较
explain SELECT * FROM `user_innodb` where name = 136;

explain SELECT * FROM `user_innodb` where name = '136';
```

3. like 条件中前面带%，需要满足前缀匹配才能用到

```sql
-- 能用到，因为可以根据前面wang来查找索引，知道索引应该往那一路分叉继续查找
explain select * from user_innodb where name like 'wang%';
-- 没有用到，因为前面字符串是不确定，无法确定前面是什么。
explain select * from user_innodb where name like '%wang';
```

4. 负向查询

NOT LIKE 不能用到索引：

```sql
explain select * from employees where last_name not like 'wang'
```

!= （<>）和NOT IN 在某些情况下可以：

```sql
explain select *from employees where emp_no not in (1)
explain select *from employees where emp_no <> 1
```

> 一个SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
> 是否使用索引由优化器决定，而优化器是基于 cost 开销判断使用那个执行计划，因此其会选择开销小（Cost Base Optimizer）的作为作为最终方案。
