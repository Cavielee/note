# 数据一致性问题

Redis 一般用来将 **热点数据** 或 **分布式数据** 从数据库缓存出来，从而减少数据库的压力，提高查询速度。

对于数据查询存在两种情况：

1. 命中缓存

![命中缓存](C:\Users\63190\Desktop\pics\命中缓存.jpg)

2. 没有命中缓存

![没有命中缓存](C:\Users\63190\Desktop\pics\没有命中缓存.jpg)

## 数据更新

当数据需要更新时，此时意味着需要对应更新 Redis 和数据库对应的数据。

因此存在两种操作顺序：

1. 先更新数据库在更新缓存
2. 新更新缓存再更新数据库

从而衍生出以下问题：

### 并发导致数据不一致

#### 数据库为旧值

1. 并发更新操作，使得前一次更新 Redis 缓存会覆盖后一次缓存值，从而数据库和 Redis 缓存值不一致。

```
线程1： ①更新Redis缓存									④更新Mysql数据
线程2： 				②更新Redis缓存	更新Mysql数据
```

可以看到先更新 Redis 缓存，再更新数据库的方案，在并发更新时会导致数据库值被旧值覆盖。

可以通过获取同一个数据库实例进行数据库更新操作，但方案严重影响读写效率，而且实际开发中数据库实例可能不止一个，无法保证。

因此应该先对数据库进行更新，再对 Redis 进行更新。

#### 缓存为旧值

1. 在更新 Redis 缓存前，其他线程并发查询该数据时，此时查询结果是旧的值。

```
线程1： ①更新Mysql数据					③更新Redis缓存
线程2： 				②读取Redis旧缓存
```

解决方案：

```sh
线程1： ①删除Redis缓存 ②更新Mysql数据					       
线程2： 							③命中Redis缓存失败，查询数据库 ④Redis缓存
```

应该在更新数据库前，删除对应 Redis 缓存，后续查询时再将数据库最新值缓存到 Redis。



2. 并发更新操作，使得前一次更新 Redis 缓存会覆盖后一次缓存值，从而数据库和 Redis 缓存值不一致。

```
线程1： ①更新Mysql数据									④更新Redis缓存
线程2： 				②更新Mysql数据	③更新Redis缓存
```

解决方案：和上述解决方案一样，只更新数据库，并且更新数据库前将 Redis 缓存删除，后续查询时再将数据库最新值缓存到 Redis。



3. 基于第一种和第二种的解决方案，首先删除 Redis 缓存再更新数据库。此时如果在删除缓存后，其他线程并发查询该数据，导致缓存了数据库旧的值，然后再更新数据库，从而导致缓存和数据库值不一致。

```
线程1： ①删除Redis缓存											④更新Mysql数据
线程2： 			②读取Redis缓存（没有命中）	③读取Mysql旧数据
```

解决方案：双删策略，对于更新数据库前后都会对缓存进行删除，从而确保更新数据库后，旧的缓存值还存在。

```
线程1： ①删除Redis缓存											④更新Mysql数据  ⑤删除Redis缓存
线程2： 			②读取Redis缓存（没有命中）	③读取Mysql旧数据
```



### 操作失败

1. 更新缓存失败。

```
①更新Mysql数据 ②更新Redis缓存（失败）
```

如果数据库更新成功，Redis 更新失败，那么将会导致缓存值一直为旧的值。

解决方案：

1. 通过对缓存设置过期时间。

2. 定期更新缓存值。

上述方案都是使得缓存和数据库的值最终一致性（中间某段时间可能存在不一致）



2. 删除缓存操作失败。

```
①删除Redis缓存	②更新Mysql数据  ③删除Redis缓存
```

解决方案：

1. 对于删除操作进行失败重试，如删除失败则放到消息队列处理。



### 总结

如果可以接受最终一致性，则可以采取：先更新数据库，在更新 Redis 缓存，Redis 缓存需要设置过期时间或者定期更新 Redis 缓存。

如果需要强一致性，则可以采取：更新数据库前后进行删除 Redis 缓存，并且当删除 Redis 缓存失败时，提供失败重试策略。



# 热点数据

Redis 中某部分数据被经常访问，我们称这部分数据为热点数据。

如何判断那些 Redis 中那些数据是热点数据？

## 客户端

客户端每对 key 进行一次读写操作，就会对 key 进行读写次数自增。

缺点：

1. 不知道要存多少个key，可能会发生内存泄露的问题。
2. 会对客户端的代码造成入侵。
3. 只能统计当前客户端的热点key。



## 代理层

第二种方式就是在代理端实现，比如 TwemProxy 或者 Codis，但是不是所有的项目都使用了代理的架构。



## 服务端

Redis 提供 monitor 的命令，可以监控到所有 Redis 执行的命令。

Facebook 的开源项目 redis-faina（https://github.com/facebookarchive/redis-faina.git）就是基于这个原理实现的。它是一个python 脚本，可以分析 monitor 的数据。

```sh
redis-cli -p 6379 monitor | head -n 100000 | ./redis-faina.py
```

这种方法也会有两个问题：

1. monitor 命令在高并发的场景下，会影响性能，所以不适合长时间使用。
2. 只能统计一个Redis 节点的热点key。

## 机器层面

通过对 TCP 协议进行抓包，也有一些开源的方案，比如ELK 的 packetbeat 插件。



# 缓存雪崩

缓存雪崩：Redis 的大量热点数据同时过期（因为设置了相同的过期时间），此时高并发场景下对失效的热点数据进行大量访问，所有的请求落到数据库，可能导致数据库瞬时压力过大而崩溃。



解决方案：

1. 获取互斥锁或者使用队列，针对同一个 key 只允许一个线程到数据库查询
2. 缓存定时预先更新，避免同时失效
3. 通过加随机数，使 key 在不同的时间过期
4. 缓存永不过期



# 缓存穿透

客户端请求查询不存在的数据。我们可以知道查询数据首先会从缓存中判断是否存在，如果不存在会再向数据库查询。由于查询的数据不存在，使得每一次都会落到数据库查询，假如存在恶意大量访问查询不存在的数据，会增加数据库压力，甚至使得数据库崩溃。



解决方案：

1. 如果数据库不存在该数据，则缓存空字符串或者特殊字符串，使得客户端下次再次访问数据库不存在的数据时，会在 Redis 缓存直接命中设置的空字符串或者特殊字符串。需要注意的是，缓存的特殊字符串需要对其设置过期时间，防止后续数据库插入了真正的记录而由于该操作被缓存拦截不能落到数据库获取到值。

   该方案也有缺陷，如果恶意每次查询不一样的数据（都是数据库不存在的），那么该方案就失去作用。

2. 布隆过滤器。

## 布隆过滤器

布隆过滤器实际可以理解为通过一种数据结构存储海量数据，并快速判断指定的数据是否存在。

显然可以对每一个数据指定一个唯一的key，并存储所有的 key。

但存在缺陷：当数据量庞大时，则需要庞大的空间去存储这些 Key。假如一个 key 大小为64字节，则100亿条记录，大概需要640G内存空间。

布隆过滤器实现如下：

1. 维护一个 m 长度的二进制的数组（bitMap 位图数据结构）。
2. 通过 K个 Hash 算法把 Key 转换成 Hash 值，并在 Hash 值对应的位上置为1。（由于 Hash 会出现碰撞，因此使用多个 Hash 可以降低碰撞概率）
3. 判断一个数据是否存在，只需要判断该数据经过步骤②得到的位上是否都为1；若都为1，则可能存在，若有一个0，则必定不存在。



优点：

通过将 key 转换成二进制数，只需要将二进制数组对应下标的值置为1即可标识一个key。假如一个key只需1位，那么10亿数据只需120M即可存储。

缺点：

1. 由于key 使用 Hash 算法获取值，通过值换算成二进制将对应 bitMap 数组下标值置为1。我们知道 Hash 算法存在碰撞，即不同的 key 可能得到的 Hash 值时相同的，因此如果 bitMap 只能判断一个元素是否可能存在，如果元素对应下标值不为1，那么该元素必不可能存在。



## 布隆过滤器实现

### Guava 实现

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>21.0</version>
</dependency>
```

```java
BloomFilter<String> bf = BloomFilter.create(
    Funnels.stringFunnel(Charsets.UTF_8), insertions);
if (bf.mightContain(data)) {
    if (sets.contains(data)) {
        // 判断存在实际存在的时候，命中
        right++;
        continue;
    }
    // 判断存在却不存在的时候，错误
    wrong++;
}
```



### Redis 实现

redis 提供一种 BitMap 的数据结构，即位图。（可以理解为一个二进制数组）

> 由于 Redis 的存储类型是 String，而 String 最多可以存储 512M的数据。因此该 BitMap 最多有2^32 个位。



- `SETBIT key offset value  `

  * offset 偏移量，可以理解为对应位的下标
  * value 为1或0

- `GETBIT key offset`

  获取offset设置的值，未设置过默认返回0

- `BITCOUNT key [start end]  `

  统计指定key位置为1的数量（区间统计不建议使用，bitcount用的是byte来计算位数，其他setbit和getbit用的是bit）

- `BITOP operation destkey key [key ...]`

​        Bit运算，BITOP 支持四种表达式运算: AND（交集）, OR（并集）, XOR（异或） 和NOT（取非）

- `BITPOS key bit [start][end]`

  返回设置为1或0的一个字符串中的第一个点的位置

例子：

```java
String userName = "Cavielee";
// ①获取到对应位的下标
int index = userName.hashCode();
// ②redis 操作
stringRedisTemplate.opsForValue().setBit("user", index, 1);
// ...省略n个hash算法（重复步骤①和②）
```
